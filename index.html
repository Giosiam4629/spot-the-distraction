<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JW Fun & Games - All-in-One</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Comic+Neue:wght@400;700&display=swap">
  <style>
    :root {
      --bg-color: #eaf5ff;
      --panel-bg: #ffffff;
      --primary-text: #3d5a80;
      --accent-green: #2a9d8f;
      --accent-red: #e76f51;
      --accent-orange: #f4a261;
      --font-header: 'Fredoka One', cursive;
      --font-body: 'Comic Neue', sans-serif;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
    }

    /* --- General Setup & Home Button --- */
    body {
      font-family: var(--font-body);
      background-color: var(--bg-color);
      color: var(--primary-text);
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .main-container {
      width: 100%;
      max-width: 900px;
    }
    .panel {
      background-color: var(--panel-bg);
      border-radius: 20px;
      padding: 20px 30px;
      box-shadow: var(--shadow);
      margin-bottom: 20px;
    }
    h2, h3 {
      font-family: var(--font-header);
      color: var(--primary-text);
      margin-top: 0;
    }
    .screen { display: none; }
    .screen.active { display: block; }
    
    #home-reset-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      background-color: var(--accent-orange);
      color: white;
      font-size: 1.8rem;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      transition: transform 0.2s ease, background-color 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #home-reset-btn:hover {
      transform: scale(1.1);
      background-color: #e76f51;
    }
    .nav-button {
      margin: 10px;
      padding: 15px 30px;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      font-family: var(--font-header);
      font-size: 1.2rem;
      color: white;
      box-shadow: var(--shadow);
    }

    /* --- Main Menu --- */
    #main-menu-screen .panel { text-align: center; }
    #character-selector { display: flex; justify-content: center; gap: 15px; margin-top: 15px; }
    #character-selector input[type="radio"] { display: none; }
    #character-selector label { padding: 8px 15px; border-radius: 50px; cursor: pointer; font-weight: bold; background-color: #f0f0f0; transition: all 0.2s ease-in-out; }
    #character-selector input[type="radio"]:checked + label { background-color: var(--accent-orange); color: white; transform: scale(1.1); }
    #game-selection-buttons { margin-top: 20px; }
    
    /* --- Sorting Game --- */
    .drop-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .dropzone { border: 3px dashed #ccc; min-height: 200px; padding: 15px; border-radius: 15px; transition: all 0.3s; }
    #closer { background-color: #e8f5e9; }
    #distraction { background-color: #ffebee; }
    .dropzone.over { transform: scale(1.02); border-color: var(--accent-orange); }
    #cards-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; min-height: 150px; padding: 20px 0; }
    .card { background-color: var(--panel-bg); border: 3px solid #ccc; padding: 15px; border-radius: 12px; cursor: grab; display: flex; align-items: center; gap: 10px; box-shadow: var(--shadow); transition: transform 0.2s; }
    .card:hover { transform: translateY(-5px); }
    .card .emoji { font-size: 2rem; }

    /* --- Memory Game --- */
    .memory-header { display: flex; justify-content: space-around; font-family: var(--font-header); font-size: 1.2rem; }
    #memory-game-grid { display: grid; gap: 10px; margin: 20px auto; max-width: 600px; }
    .memory-card { width: 100%; aspect-ratio: 1 / 1; position: relative; transform-style: preserve-3d; transition: transform 0.6s; cursor: pointer; }
    .memory-card.is-flipped { transform: rotateY(180deg); }
    .memory-card.is-matched { opacity: 0.5; pointer-events: none; }
    .card-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; align-items: center; justify-content: center; flex-direction: column; border-radius: 10px; }
    .card-front { background: white; border: 3px solid #ccc; transform: rotateY(180deg); }
    .card-back { background: linear-gradient(135deg, #6a0dad, #9c27b0); font-size: 3rem; color: white; }

    /* --- Minigame --- */
    #minigame-screen { text-align: center; }
    .minigame-header { display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; }
    .minigame-stat { font-family: var(--font-header); font-size: 1.2rem; }
    .minigame-stat .hearts { font-size: 1.8rem; letter-spacing: 2px; }
    #minigame-canvas-container { position: relative; background-color: #7ec0ee; border-radius: 15px; overflow: hidden; box-shadow: var(--shadow); }
    canvas#minigame-canvas { width: 100%; display: block; }
    #minigame-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: none; flex-direction: column; align-items: center; justify-content: center; color: white; text-shadow: 2px 2px 4px #000; font-family: var(--font-header); background: rgba(0,0,0,0.4); }
    #minigame-overlay h2 { font-size: 3rem; margin-bottom: 20px; }
    #minigame-start-btn, #minigame-next-level-btn { padding: 15px 30px; font-size: 1.5rem; background-color: var(--accent-orange); color: white; border: none; border-radius: 15px; cursor: pointer; margin-top: 10px; }
  </style>
</head>
<body>

<button id="home-reset-btn" title="Reset Game and Go Home">üè†</button>

<div class="main-container">

  <div id="main-menu-screen" class="screen active">
    <div class="panel">
      <h2>JW Fun & Games!</h2>
      <p>Choose your character and pick a game to play.</p>
      <div id="character-selector">
        <input type="radio" id="char-boy" name="character" value="boy" checked><label for="char-boy">Boy üë¶</label>
        <input type="radio" id="char-girl" name="character" value="girl"><label for="char-girl">Girl üëß</label>
      </div>
      <div id="game-selection-buttons">
        <button id="start-sorting-btn" class="nav-button" style="background-color: var(--accent-green);">Spot the Distraction</button>
        <button id="start-memory-btn" class="nav-button" style="background-color: #9c27b0;">Memory Match</button>
        <button id="start-minigame-btn" class="nav-button" style="background-color: #2196F3;">Platform Adventure</button>
      </div>
    </div>
  </div>

  <div id="sorting-game-screen" class="screen">
     </div>

  <div id="memory-game-screen" class="screen">
      </div>

  <div id="minigame-screen" class="screen">
    <div class="panel">
      <h2>Platform Adventure!</h2>
      <div class="minigame-header">
        <div class="minigame-stat">Level: <span id="minigame-level">1</span></div>
        <div class="minigame-stat">Tokens: <span id="minigame-tokens">0</span> / <span id="minigame-goal">5</span></div>
        <div class="minigame-stat"><span class="hearts" id="minigame-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
      </div>
      <div id="minigame-canvas-container">
          <canvas id="minigame-canvas" width="800" height="450"></canvas>
          <div id="minigame-overlay">
              <h2 id="minigame-message"></h2>
              <button id="minigame-start-btn">Start Adventure üöÄ</button>
              <button id="minigame-next-level-btn" style="display:none;">Next Level! ‚ú®</button>
          </div>
      </div>
    </div>
  </div>
</div>

<script>
// --- GLOBAL STATE & SCREEN MANAGEMENT ---
const initialGameState = {
    character: 'boy',
    activeScreen: 'main-menu-screen'
};
let game = { ...initialGameState };

function switchScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
    game.activeScreen = screenId;
    
    if (platformFighter.active) platformFighter.endGame(false, true);
    // Add similar logic for other games if they have active loops
}

function resetAndGoHome() {
    game = { ...initialGameState };
    document.getElementById(`char-${game.character}`).checked = true;
    switchScreen('main-menu-screen');
}

document.getElementById('home-reset-btn').onclick = resetAndGoHome;

// --- PLATFORM ADVENTURE MINIGAME (NEW!) ---
const platformFighter = {
    canvas: document.getElementById('minigame-canvas'),
    ctx: null, active: false, gameInterval: null, frame: 0,
    level: 1, lives: 3, tokens: 0, goal: 5,
    
    // --- Game Objects & State ---
    player: {
        x: 100, y: 300, w: 40, h: 60, vx: 0, vy: 0, speed: 5, jumpPower: 18,
        grounded: true, isInvincible: false, invincibleTimer: 0,
        animState: 'idle', animFrame: 0, facing: 'right'
    },
    platforms: [],
    tokens: [],
    obstacles: [],
    backgroundLayers: [],
    gravity: 0.8,
    camera: { x: 0 },

    // --- Drawing & Animation Data ---
    characterArt: {
        boy: { skin: '#f2a66e', hair: '#3a2d27', shirt: '#4a90e2', pants: '#333' },
        girl: { skin: '#ffbe87', hair: '#8b572a', shirt: '#e91e63', pants: '#555' }
    },
    
    // --- Core Functions ---
    init() {
        this.ctx = this.canvas.getContext('2d');
        document.getElementById('minigame-start-btn').onclick = () => this.start();
        document.getElementById('minigame-next-level-btn').onclick = () => { this.level++; this.start(); };
        this.showOverlay("Platform Adventure");
        // Key listeners for movement will be added in start()
    },

    start() {
        this.hideOverlay(); this.active = true; this.frame = 0; this.level = 1; this.lives = 3;
        this.player.x = 100; this.player.y = 300; this.camera.x = 0;
        this.generateLevel();
        if (this.gameInterval) clearInterval(this.gameInterval);
        this.gameInterval = setInterval(() => this.loop(), 1000 / 60);
        this.addKeyListeners();
    },

    keys: {},
    addKeyListeners() {
        this.keys = {};
        window.onkeydown = e => this.keys[e.code] = true;
        window.onkeyup = e => this.keys[e.code] = false;
    },
    
    generateLevel() {
        this.platforms = [{x: 0, y: 400, w: 1000, h: 50}];
        for (let i = 1; i < 20; i++) {
            this.platforms.push({
                x: this.platforms[i-1].x + Math.random() * 200 + 200,
                y: 400 - Math.random() * 150,
                w: Math.random() * 100 + 100,
                h: 30
            });
        }
        // Simplified for example
    },

    loop() {
        this.updatePlayerState();
        this.updateCamera();
        this.draw();
    },

    updatePlayerState() {
        // Horizontal Movement
        if (this.keys.ArrowLeft || this.keys.KeyA) { this.player.vx = -this.player.speed; this.player.facing = 'left'; }
        else if (this.keys.ArrowRight || this.keys.KeyD) { this.player.vx = this.player.speed; this.player.facing = 'right'; }
        else { this.player.vx = 0; }
        
        // Jumping
        if ((this.keys.Space || this.keys.ArrowUp || this.keys.KeyW) && this.player.grounded) {
            this.player.vy = -this.player.jumpPower; this.player.grounded = false;
        }

        // Apply physics
        this.player.vy += this.gravity;
        this.player.x += this.player.vx;
        this.player.y += this.player.vy;
        this.player.grounded = false;

        // Collision with platforms
        this.platforms.forEach(p => {
            if (this.player.y + this.player.h > p.y && this.player.y + this.player.h < p.y + p.h &&
                this.player.x + this.player.w > p.x && this.player.x < p.x + p.w && this.player.vy > 0) {
                this.player.grounded = true; this.player.y = p.y - this.player.h; this.player.vy = 0;
            }
        });
        
        // Update animation state
        this.player.animFrame++;
        if (!this.player.grounded) { this.player.animState = this.player.vy < 0 ? 'jump' : 'fall'; }
        else if (this.player.vx !== 0) { this.player.animState = 'run'; }
        else { this.player.animState = 'idle'; }
    },
    
    updateCamera() {
        // Camera follows player smoothly
        const targetX = this.player.x - this.canvas.width / 3;
        this.camera.x += (targetX - this.camera.x) * 0.1;
    },
    
    // --- Drawing Functions ---
    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.save();
        this.ctx.translate(-this.camera.x, 0);

        this.drawBackground();
        this.drawPlatforms();
        this.drawCharacter();

        this.ctx.restore();
    },
    
    drawBackground() {
        // Draw soft, multi-layered clouds/hills
        this.ctx.fillStyle = '#bde0fe'; this.ctx.fillRect(this.camera.x, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = '#a2d2ff';
        this.ctx.beginPath(); this.ctx.ellipse(this.camera.x + 200, 200, 150, 50, 0, 0, Math.PI * 2); this.ctx.fill();
        this.ctx.ellipse(this.camera.x + 500, 150, 200, 70, 0, 0, Math.PI * 2); this.ctx.fill();
    },

    drawPlatforms() {
        this.platforms.forEach(p => {
            this.ctx.fillStyle = '#2a9d8f'; this.ctx.fillRect(p.x, p.y, p.w, p.h);
            this.ctx.fillStyle = '#264653'; this.ctx.fillRect(p.x, p.y + p.h - 10, p.w, 10);
        });
    },

    drawCharacter() {
        const p = this.player;
        const art = this.characterArt[game.character];
        const frame = p.animFrame;
        const ctx = this.ctx;

        ctx.save();
        ctx.translate(p.x + p.w / 2, p.y + p.h);
        if (p.facing === 'left') ctx.scale(-1, 1);

        // Animation logic
        let bob = Math.sin(frame * 0.4) * 3;
        let armSwing = Math.sin(frame * 0.3) * 25;
        let legSwing = Math.sin(frame * 0.3) * 35;

        if (p.animState === 'idle') { armSwing /= 4; legSwing = 0; }
        if (p.animState === 'jump' || p.animState === 'fall') {
            bob = 0; armSwing = -20; legSwing = 20;
            if (p.animState === 'fall') { armSwing = 20; legSwing = -20; }
        }

        // Body parts drawing
        const drawLimb = (angle, length, width, color) => {
            ctx.rotate(angle * Math.PI / 180);
            ctx.fillStyle = color;
            ctx.fillRect(-width/2, 0, width, -length);
            ctx.beginPath(); ctx.arc(0, -length, width/2, 0, Math.PI * 2); ctx.fill();
            ctx.rotate(-angle * Math.PI / 180);
        };
        
        // Legs
        ctx.save(); ctx.translate(0, -p.h/2.5); drawLimb(legSwing, 25, 10, art.pants); ctx.restore(); // Back leg
        ctx.save(); ctx.translate(0, -p.h/2.5); drawLimb(-legSwing, 28, 12, art.pants); ctx.restore(); // Front leg
        
        // Arms
        ctx.save(); ctx.translate(0, -p.h/1.5); drawLimb(-armSwing, 22, 8, art.skin); ctx.restore(); // Back arm
        
        // Torso
        ctx.fillStyle = art.shirt;
        ctx.beginPath(); ctx.ellipse(0, -p.h/1.8 + bob, 15, 20, 0, 0, Math.PI * 2); ctx.fill();

        ctx.save(); ctx.translate(0, -p.h/1.5); drawLimb(armSwing, 25, 10, art.skin); ctx.restore(); // Front arm

        // Head
        ctx.fillStyle = art.skin;
        ctx.beginPath(); ctx.arc(0, -p.h/1.2 + bob * 1.2, 15, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = art.hair;
        ctx.beginPath(); ctx.arc(0, -p.h/1.2 + bob * 1.2, 16, Math.PI, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'white'; // Eye
        ctx.beginPath(); ctx.arc(8, -p.h/1.15 + bob * 1.2, 4, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'black'; // Pupil
        ctx.beginPath(); ctx.arc(9, -p.h/1.15 + bob * 1.2, 2, 0, Math.PI * 2); ctx.fill();

        ctx.restore();
    },

    // --- Overlay & Game State Functions ---
    showOverlay(message, showNextLevelBtn = false) {
        const overlay = document.getElementById('minigame-overlay');
        document.getElementById('minigame-message').textContent = message;
        document.getElementById('minigame-start-btn').style.display = showNextLevelBtn ? 'none' : 'inline-block';
        document.getElementById('minigame-next-level-btn').style.display = showNextLevelBtn ? 'inline-block' : 'none';
        overlay.style.display = 'flex';
    },
    hideOverlay() { document.getElementById('minigame-overlay').style.display = 'none'; },
    endGame(isComplete = false, isReset = false) {
        this.active = false;
        clearInterval(this.gameInterval);
        window.onkeydown = null; window.onkeyup = null;
        if (isReset) return;
        if (!isComplete) this.showOverlay("Game Over");
    },
    
    updateUI() { /* Update UI elements like lives, tokens, etc. */ }
};


// --- MEMORY GAME & SORTING GAME (STUBS FOR BREVITY) ---
// In the final file, the full JS objects for these games would be here.
const memoryGame = { start() { alert("Memory Game Started!"); } };
const sortingGame = { start() { alert("Sorting Game Started!"); } };


// --- INITIALIZATION & EVENT LISTENERS ---
window.onload = () => {
    document.getElementById('start-sorting-btn').onclick = () => {
        switchScreen('sorting-game-screen');
        // sortingGame.start(); // This would be the full function call
    };
    document.getElementById('start-memory-btn').onclick = () => {
        switchScreen('memory-game-screen');
        // memoryGame.start(); // This would be the full function call
    };
    document.getElementById('start-minigame-btn').onclick = () => {
        switchScreen('minigame-screen');
        platformFighter.init();
    };
    document.getElementById('character-selector').onchange = (e) => {
        game.character = e.target.value;
    };
};
</script>
</body>
</html>

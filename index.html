<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JW Fun & Games - All-in-One Enhanced</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Comic+Neue:wght@400;700&display=swap">
  <style>
    :root {
      --bg-color: #eaf5ff;
      --panel-bg: #ffffff;
      --primary-text: #3d5a80;
      --accent-green: #2a9d8f;
      --accent-red: #e76f51;
      --accent-orange: #f4a261;
      --font-header: 'Fredoka One', cursive;
      --font-body: 'Comic Neue', sans-serif;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
    }

    /* --- General Setup & Home Button --- */
    body {
      font-family: var(--font-body);
      background-color: var(--bg-color);
      color: var(--primary-text);
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .main-container {
      width: 100%;
      max-width: 900px;
    }
    .panel {
      background-color: var(--panel-bg);
      border-radius: 20px;
      padding: 20px 30px;
      box-shadow: var(--shadow);
      margin-bottom: 20px;
    }
    h2, h3 {
      font-family: var(--font-header);
      color: var(--primary-text);
      margin-top: 0;
    }
    .screen { display: none; }
    .screen.active { display: block; }
    
    #home-reset-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      background-color: var(--accent-orange);
      color: white;
      font-size: 1.8rem;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      transition: transform 0.2s ease, background-color 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #home-reset-btn:hover {
      transform: scale(1.1);
      background-color: #e76f51;
    }
    .nav-button {
      margin: 10px;
      padding: 15px 30px;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      font-family: var(--font-header);
      font-size: 1.2rem;
      color: white;
      box-shadow: var(--shadow);
    }

    /* --- Main Menu --- */
    #main-menu-screen .panel { text-align: center; }
    #character-selector { display: flex; justify-content: center; gap: 15px; margin-top: 15px; }
    #character-selector input[type="radio"] { display: none; }
    #character-selector label { padding: 8px 15px; border-radius: 50px; cursor: pointer; font-weight: bold; background-color: #f0f0f0; transition: all 0.2s ease-in-out; }
    #character-selector input[type="radio"]:checked + label { background-color: var(--accent-orange); color: white; transform: scale(1.1); }
    #game-selection-buttons { margin-top: 20px; }
    
    /* --- Sorting Game --- */
    .drop-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .dropzone { border: 3px dashed #ccc; min-height: 200px; padding: 15px; border-radius: 15px; transition: all 0.3s; }
    #closer { background-color: #e8f5e9; }
    #distraction { background-color: #ffebee; }
    .dropzone.over { transform: scale(1.02); border-color: var(--accent-orange); }
    #cards-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; min-height: 150px; padding: 20px 0; }
    .card { background-color: var(--panel-bg); border: 3px solid #ccc; padding: 15px; border-radius: 12px; cursor: grab; display: flex; align-items: center; gap: 10px; box-shadow: var(--shadow); transition: transform 0.2s; }
    .card:hover { transform: translateY(-5px); }
    .card .emoji { font-size: 2rem; }

    /* --- Memory Game --- */
    .memory-header { display: flex; justify-content: space-around; font-family: var(--font-header); font-size: 1.2rem; }
    #memory-game-grid { display: grid; gap: 10px; margin: 20px auto; max-width: 600px; }
    .memory-card { width: 100%; aspect-ratio: 1 / 1; position: relative; transform-style: preserve-3d; transition: transform 0.6s; cursor: pointer; }
    .memory-card.is-flipped { transform: rotateY(180deg); }
    .memory-card.is-matched { opacity: 0.5; pointer-events: none; }
    .card-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; align-items: center; justify-content: center; flex-direction: column; border-radius: 10px; }
    .card-front { background: white; border: 3px solid #ccc; transform: rotateY(180deg); font-size: 3rem; }
    .card-back { background: linear-gradient(135deg, #6a0dad, #9c27b0); font-size: 3rem; color: white; }

    /* --- Enhanced Minigame --- */
    #minigame-screen { text-align: center; }
    .minigame-header { display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    .minigame-stat { font-family: var(--font-header); font-size: 1.2rem; }
    .minigame-stat .hearts { font-size: 1.8rem; letter-spacing: 2px; }
    #minigame-canvas-container { position: relative; background-color: #7ec0ee; border-radius: 15px; overflow: hidden; box-shadow: var(--shadow); }
    canvas#minigame-canvas { width: 100%; display: block; }
    #minigame-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: none; flex-direction: column; align-items: center; justify-content: center; color: white; text-shadow: 2px 2px 4px #000; font-family: var(--font-header); background: rgba(0,0,0,0.4); }
    #minigame-overlay h2 { font-size: 3rem; margin-bottom: 20px; }
    #minigame-start-btn, #minigame-next-level-btn { padding: 15px 30px; font-size: 1.5rem; background-color: var(--accent-orange); color: white; border: none; border-radius: 15px; cursor: pointer; margin-top: 10px; }
    
    /* Controls info */
    .controls-info { 
      font-size: 0.9rem; 
      color: var(--primary-text); 
      margin-top: 10px; 
      text-align: center; 
    }
  </style>
</head>
<body>

<button id="home-reset-btn" title="Reset Game and Go Home">üè†</button>

<div class="main-container">

  <div id="main-menu-screen" class="screen active">
    <div class="panel">
      <h2>JW Fun & Games!</h2>
      <p>Choose your character and pick a game to play.</p>
      <div id="character-selector">
        <input type="radio" id="char-boy" name="character" value="boy" checked><label for="char-boy">Boy üë¶</label>
        <input type="radio" id="char-girl" name="character" value="girl"><label for="char-girl">Girl üëß</label>
      </div>
      <div id="game-selection-buttons">
        <button id="start-sorting-btn" class="nav-button" style="background-color: var(--accent-green);">Spot the Distraction</button>
        <button id="start-memory-btn" class="nav-button" style="background-color: #9c27b0;">Memory Match</button>
        <button id="start-minigame-btn" class="nav-button" style="background-color: #2196F3;">Platform Adventure</button>
      </div>
    </div>
  </div>

  <div id="sorting-game-screen" class="screen">
    <div class="panel">
        <h2>Spot the Distraction</h2>
        <div class="drop-container">
            <div id="closer" class="dropzone"><h3>üëç Keeps Me Close to Jehovah</h3></div>
            <div id="distraction" class="dropzone"><h3>ü§î Could Be a Distraction</h3></div>
        </div>
        <h3 style="text-align: center;">Drag the Activities</h3>
        <div id="cards-container"></div>
    </div>
  </div>

  <div id="memory-game-screen" class="screen">
      <div class="panel">
          <h2>Memory Match Challenge</h2>
          <div class="memory-header">
              <span>Level: <span id="memory-level">1</span></span>
              <span>Matches: <span id="memory-matches">0 / 0</span></span>
              <span>Time: <span id="memory-timer">--</span></span>
          </div>
          <div id="memory-game-grid"></div>
      </div>
  </div>

  <div id="minigame-screen" class="screen">
    <div class="panel">
      <h2>Platform Adventure!</h2>
      <div class="minigame-header">
        <div class="minigame-stat">Level: <span id="minigame-level">1</span></div>
        <div class="minigame-stat">Tokens: <span id="minigame-tokens">0 / 5</span></div>
        <div class="minigame-stat">Score: <span id="minigame-score">0</span></div>
        <div class="minigame-stat"><span class="hearts" id="minigame-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
      </div>
      <div class="controls-info">
        üéÆ Controls: Arrow Keys/WASD to move, Space/Up to jump (double jump available!)
      </div>
      <div id="minigame-canvas-container">
          <canvas id="minigame-canvas" width="800" height="450"></canvas>
          <div id="minigame-overlay">
              <h2 id="minigame-message"></h2>
              <button id="minigame-start-btn">Start Adventure üöÄ</button>
              <button id="minigame-next-level-btn" style="display:none;">Next Level! ‚ú®</button>
          </div>
      </div>
    </div>
  </div>
</div>

<script>
// --- GLOBAL & MENU LOGIC ---
const initialGameState = { character: 'boy' };
let game = { ...initialGameState };

function switchScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
    
    if (platformFighter.active) platformFighter.endGame(false, true);
    if (memoryGame.timerId) clearInterval(memoryGame.timerId);
    if (sortingGame.active) sortingGame.endGame();
}

function resetAndGoHome() {
    game = { ...initialGameState };
    document.getElementById(`char-${game.character}`).checked = true;
    switchScreen('main-menu-screen');
}

document.getElementById('home-reset-btn').onclick = resetAndGoHome;

// --- ENHANCED PLATFORM ADVENTURE MINIGAME ---
const platformFighter = {
    canvas: document.getElementById('minigame-canvas'),
    ctx: null, active: false, gameInterval: null, frame: 0,
    level: 1, lives: 3, tokens: 0, goal: 5, score: 0,
    
    player: {
        x: 100, y: 300, w: 40, h: 60, vx: 0, vy: 0, speed: 6, jumpPower: 18,
        grounded: true, isInvincible: false, invincibleTimer: 0,
        animState: 'idle', animFrame: 0, facing: 'right', squash: 0,
        doubleJumpAvailable: true, hasDoubleJumped: false
    },
    
    platforms: [], particles: [], collectibles: [], enemies: [], movingPlatforms: [], checkpoints: [],
    gravity: 0.8, camera: { x: 0 }, levelWidth: 3000,
    
    // Sound effects (simple beep sounds using Web Audio API)
    audioContext: null,
    
    characterArt: {
        boy: { skin: '#f2a66e', skin_s: '#d88c57', hair: '#3a2d27', shirt: '#4a90e2', shirt_s: '#3b73b5', pants: '#333', pants_s: '#222' },
        girl: { skin: '#ffbe87', skin_s: '#e5a36f', hair: '#8b572a', shirt: '#e91e63', shirt_s: '#c2185b', pants: '#555', pants_s: '#444' }
    },
    
    init() {
        this.ctx = this.canvas.getContext('2d');
        this.initAudio();
        document.getElementById('minigame-start-btn').onclick = () => this.start();
        document.getElementById('minigame-next-level-btn').onclick = () => { this.nextLevel(); };
        this.showOverlay("Platform Adventure");
    },

    initAudio() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.log('Web Audio API not supported');
        }
    },

    playSound(frequency, duration = 0.1, type = 'sine') {
        if (!this.audioContext) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + duration);
    },

    start() {
        this.hideOverlay(); 
        this.active = true; 
        this.frame = 0; 
        this.level = 1; 
        this.lives = 3; 
        this.tokens = 0; 
        this.score = 0;
        this.player.x = 100; 
        this.player.y = 300; 
        this.camera.x = 0;
        this.player.doubleJumpAvailable = true;
        this.player.hasDoubleJumped = false;
        this.generateLevel();
        if (this.gameInterval) clearInterval(this.gameInterval);
        this.gameInterval = setInterval(() => this.loop(), 1000 / 60);
        this.addKeyListeners();
    },

    nextLevel() {
        this.level++;
        this.tokens = 0;
        this.goal = Math.min(5 + this.level, 10);
        this.player.x = 100;
        this.player.y = 300;
        this.camera.x = 0;
        this.player.doubleJumpAvailable = true;
        this.player.hasDoubleJumped = false;
        this.generateLevel();
        this.hideOverlay();
    },

    keys: {},
    addKeyListeners() {
        this.keys = {};
        window.onkeydown = e => {
            this.keys[e.code] = true;
            // Resume audio context on first user interaction
            if (this.audioContext && this.audioContext.state === 'suspended') {
                this.audioContext.resume();
            }
        };
        window.onkeyup = e => this.keys[e.code] = false;
    },
    
    generateLevel() {
        // Clear all arrays
        this.platforms = [];
        this.collectibles = [];
        this.enemies = [];
        this.movingPlatforms = [];
        this.checkpoints = [];
        
        // Ground platform
        this.platforms.push({x: -200, y: 400, w: this.levelWidth + 400, h: 50});
        
        // Generate platforms with increasing complexity
        const platformCount = 15 + this.level * 3;
        let lastX = 200;
        
        for (let i = 0; i < platformCount; i++) {
            const platform = {
                x: lastX + Math.random() * 150 + 200,
                y: 400 - Math.random() * 200 - 50,
                w: Math.random() * 80 + 100,
                h: 25
            };
            this.platforms.push(platform);
            lastX = platform.x;
            
            // Add collectible tokens (golden coins)
            if (Math.random() < 0.6) {
                this.collectibles.push({
                    x: platform.x + platform.w / 2 - 15,
                    y: platform.y - 40,
                    w: 30, h: 30,
                    type: 'token',
                    collected: false,
                    animFrame: 0
                });
            }
            
            // Add enemies (simple red moving creatures)
            if (i > 2 && Math.random() < 0.3 + this.level * 0.1) {
                this.enemies.push({
                    x: platform.x + 20,
                    y: platform.y - 30,
                    w: 25, h: 25,
                    vx: (Math.random() < 0.5 ? -1 : 1) * (1 + this.level * 0.2),
                    platformX: platform.x,
                    platformW: platform.w,
                    animFrame: 0
                });
            }
        }
        
        // Add moving platforms
        const movingPlatformCount = Math.min(this.level, 4);
        for (let i = 0; i < movingPlatformCount; i++) {
            this.movingPlatforms.push({
                x: 800 + i * 600,
                y: 300 - i * 40,
                w: 120, h: 20,
                vx: 1 + Math.random(),
                startX: 800 + i * 600,
                endX: 800 + i * 600 + 200,
                direction: 1
            });
        }
        
        // Add checkpoints
        for (let i = 1; i <= 3; i++) {
            this.checkpoints.push({
                x: (this.levelWidth / 4) * i,
                y: 350,
                w: 40, h: 50,
                activated: false,
                animFrame: 0
            });
        }
    },

    loop() {
        this.updatePlayerState();
        this.updateEnemies();
        this.updateMovingPlatforms();
        this.updateCollectibles();
        this.updateCheckpoints();
        this.updateCamera();
        this.updateParticles();
        this.checkCollisions();
        this.checkLevelComplete();
        this.draw();
        this.updateUI();
        this.frame++;
    },

    updatePlayerState() {
        const p = this.player;
        if (p.squash > 0) p.squash -= 0.1;
        if (p.isInvincible && p.invincibleTimer > 0) {
            p.invincibleTimer--;
            if (p.invincibleTimer <= 0) p.isInvincible = false;
        }

        // Movement
        if (this.keys.KeyA || this.keys.ArrowLeft) { 
            p.vx = -p.speed; 
            p.facing = 'left'; 
        }
        else if (this.keys.KeyD || this.keys.ArrowRight) { 
            p.vx = p.speed; 
            p.facing = 'right'; 
        }
        else { 
            p.vx *= 0.8; // Friction
        }
        
        // Jumping with double jump
        if ((this.keys.KeyW || this.keys.ArrowUp || this.keys.Space)) {
            if (p.grounded && !this.jumpKeyPressed) {
                p.vy = -p.jumpPower; 
                p.grounded = false;
                p.doubleJumpAvailable = true;
                p.hasDoubleJumped = false;
                this.spawnParticles(p.x + p.w / 2, p.y + p.h, 10, '#f4a261');
                this.playSound(440, 0.1);
                this.jumpKeyPressed = true;
            } else if (!p.grounded && p.doubleJumpAvailable && !p.hasDoubleJumped && !this.jumpKeyPressed) {
                p.vy = -p.jumpPower * 0.8;
                p.hasDoubleJumped = true;
                p.doubleJumpAvailable = false;
                this.spawnParticles(p.x + p.w / 2, p.y + p.h / 2, 15, '#87CEEB');
                this.playSound(550, 0.1);
                this.jumpKeyPressed = true;
            }
        } else {
            this.jumpKeyPressed = false;
        }

        // Physics
        p.vy += this.gravity;
        p.x += p.vx;
        p.y += p.vy;
        
        // Platform collision
        let onPlatform = false;
        [...this.platforms, ...this.movingPlatforms].forEach(plat => {
            if (p.x + p.w > plat.x && p.x < plat.x + plat.w &&
                p.y + p.h > plat.y && p.y + p.h < plat.y + 20 && p.vy >= 0) {
                if (!p.grounded) {
                    p.squash = 1;
                    this.spawnParticles(p.x + p.w / 2, p.y + p.h, 15, '#ffffff');
                    p.doubleJumpAvailable = true;
                    p.hasDoubleJumped = false;
                }
                onPlatform = true; 
                p.y = plat.y - p.h; 
                p.vy = 0;
                
                // Move with moving platform
                if (plat.vx) p.x += plat.vx;
            }
        });
        p.grounded = onPlatform;
        
        // Death by falling
        if (p.y > 500) {
            this.takeDamage();
        }
        
        // Animation states
        p.animFrame++;
        if (!p.grounded) p.animState = p.vy < 0 ? 'jump' : 'fall';
        else if (Math.abs(p.vx) > 0.5) p.animState = 'run';
        else p.animState = 'idle';
    },

    updateEnemies() {
        this.enemies.forEach(enemy => {
            enemy.animFrame++;
            enemy.x += enemy.vx;
            
            // Bounce off platform edges
            if (enemy.x <= enemy.platformX || enemy.x + enemy.w >= enemy.platformX + enemy.platformW) {
                enemy.vx *= -1;
            }
        });
    },

    updateMovingPlatforms() {
        this.movingPlatforms.forEach(platform => {
            platform.x += platform.vx * platform.direction;
            
            if (platform.x <= platform.startX || platform.x >= platform.endX) {
                platform.direction *= -1;
            }
        });
    },

    updateCollectibles() {
        this.collectibles.forEach(collectible => {
            if (!collectible.collected) {
                collectible.animFrame++;
            }
        });
    },

    updateCheckpoints() {
        this.checkpoints.forEach(checkpoint => {
            checkpoint.animFrame++;
        });
    },

    checkCollisions() {
        const p = this.player;
        
        // Collectible collision
        this.collectibles.forEach(collectible => {
            if (!collectible.collected && 
                p.x + p.w > collectible.x && p.x < collectible.x + collectible.w &&
                p.y + p.h > collectible.y && p.y < collectible.y + collectible.h) {
                collectible.collected = true;
                this.tokens++;
                this.score += 100;
                this.spawnParticles(collectible.x + collectible.w/2, collectible.y + collectible.h/2, 20, '#FFD700');
                this.playSound(660, 0.2);
            }
        });
        
        // Enemy collision
        if (!p.isInvincible) {
            this.enemies.forEach(enemy => {
                if (p.x + p.w > enemy.x && p.x < enemy.x + enemy.w &&
                    p.y + p.h > enemy.y && p.y < enemy.y + enemy.h) {
                    this.takeDamage();
                }
            });
        }
        
        // Checkpoint collision
        this.checkpoints.forEach(checkpoint => {
            if (!checkpoint.activated &&
                p.x + p.w > checkpoint.x && p.x < checkpoint.x + checkpoint.w &&
                p.y + p.h > checkpoint.y && p.y < checkpoint.y + checkpoint.h) {
                checkpoint.activated = true;
                this.spawnParticles(checkpoint.x + checkpoint.w/2, checkpoint.y, 25, '#00FF00');
                this.playSound(880, 0.3);
                this.score += 50;
            }
        });
    },

    takeDamage() {
        if (this.player.isInvincible) return;
        
        this.lives--;
        this.player.isInvincible = true;
        this.player.invincibleTimer = 120; // 2 seconds at 60fps
        this.spawnParticles(this.player.x + this.player.w/2, this.player.y + this.player.h/2, 30, '#FF0000');
        this.playSound(220, 0.5, 'sawtooth');
        
        if (this.lives <= 0) {
            this.endGame(false);
        } else {
            // Respawn at last checkpoint or start
            const lastCheckpoint = this.checkpoints.filter(c => c.activated).pop();
            if (lastCheckpoint) {
                this.player.x = lastCheckpoint.x;
                this.player.y = lastCheckpoint.y - this.player.h;
            } else {
                this.player.x = 100;
                this.player.y = 300;
            }
            this.player.vx = 0;
            this.player.vy = 0;
        }
    },

    checkLevelComplete() {
        if (this.tokens >= this.goal) {
            this.score += this.level * 500 + this.lives * 200;
            this.showOverlay(`Level ${this.level} Complete! üéâ`, true);
        }
    },
    
    updateCamera() {
        const targetX = this.player.x - this.canvas.width / 3;
        this.camera.x += (targetX - this.camera.x) * 0.1;
        this.camera.x = Math.max(0, Math.min(this.camera.x, this.levelWidth - this.canvas.width));
    },
    
    spawnParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 6,
                vy: (Math.random() - 0.5) * 6 - 2,
                life: Math.random() * 40 + 20,
                color,
                size: Math.random() * 4 + 2
            });
        }
    },
    
    updateParticles() {
        this.particles.forEach((p, i) => {
            p.x += p.vx; 
            p.y += p.vy; 
            p.vy += 0.2; // Gravity on particles
            p.life--;
            if (p.life <= 0) this.particles.splice(i, 1);
        });
    },

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.save();
        this.ctx.translate(-this.camera.x, 0);
        
        this.drawBackground();
        this.drawPlatforms();
        this.drawMovingPlatforms();
        this.drawCollectibles();
        this.drawEnemies();
        this.drawCheckpoints();
        this.drawParticles();
        this.drawCharacter();
        
        this.ctx.restore();
    },
    
    drawBackground() {
        // Sky gradient
        const grad = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        grad.addColorStop(0, '#87CEEB'); 
        grad.addColorStop(1, '#bde0fe');
        this.ctx.fillStyle = grad;
        this.ctx.fillRect(this.camera.x, 0, this.canvas.width, this.canvas.height);
        
        // Clouds with parallax
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        for (let i = 0; i < 5; i++) {
            const x = 200 + i * 400 - this.camera.x * 0.3;
            const y = 80 + Math.sin(i) * 30;
            this.ctx.beginPath();
            this.ctx.ellipse(x, y, 80 + i * 10, 30, 0, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // Sun
        this.ctx.fillStyle = '#FFD700';
        this.ctx.beginPath();
        this.ctx.arc(this.canvas.width - 100 + this.camera.x * 0.1, 80, 40, 0, Math.PI * 2);
        this.ctx.fill();
    },

    drawPlatforms() {
        this.platforms.forEach(p => {
            // Platform shadow
            this.ctx.fillStyle = '#5d4037'; 
            this.ctx.fillRect(p.x, p.y, p.w, p.h);
            // Grass top
            this.ctx.fillStyle = '#8bc34a'; 
            this.ctx.fillRect(p.x, p.y, p.w, 8);
            // Grass details
            this.ctx.fillStyle = '#689f38';
            for (let i = 0; i < p.w; i += 10) {
                this.ctx.fillRect(p.x + i, p.y, 2, 12);
            }
        });
    },

    drawMovingPlatforms() {
        this.movingPlatforms.forEach(p => {
            this.ctx.fillStyle = '#795548';
            this.ctx.fillRect(p.x, p.y, p.w, p.h);
            this.ctx.fillStyle = '#a1887f';
            this.ctx.fillRect(p.x, p.y, p.w, 6);
            
            // Movement indicator
            this.ctx.fillStyle = '#ff9800';
            const indicatorX = p.x + (Math.sin(this.frame * 0.1) + 1) * p.w / 2 - 5;
            this.ctx.fillRect(indicatorX, p.y - 5, 10, 3);
        });
    },

    drawCollectibles() {
        this.collectibles.forEach(collectible => {
            if (collectible.collected) return;
            
            const bounce = Math.sin(collectible.animFrame * 0.1) * 5;
            const rotation = collectible.animFrame * 0.05;
            
            this.ctx.save();
            this.ctx.translate(collectible.x + collectible.w/2, collectible.y + collectible.h/2 + bounce);
            this.ctx.rotate(rotation);
            
            // Golden token
            this.ctx.fillStyle = '#FFD700';
            this.ctx.beginPath();
            this.ctx.arc(0, 0, 12, 0, Math.PI * 2);
            this.ctx.fill();
            
            this.ctx.fillStyle = '#FFA000';
            this.ctx.beginPath();
            this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Sparkle effect
            this.ctx.fillStyle = '#FFFFFF';
            this.ctx.fillRect(-1, -8, 2, 16);
            this.ctx.fillRect(-8, -1, 16, 2);
            
            this.ctx.restore();
        });
    },

    drawEnemies() {
        this.enemies.forEach(enemy => {
            const bounce = Math.sin(enemy.animFrame * 0.2) * 2;
            
            this.ctx.save();
            this.ctx.translate(enemy.x + enemy.w/2, enemy.y + enemy.h + bounce);
            
            // Simple enemy creature
            this.ctx.fillStyle = '#f44336';
            this.ctx.beginPath();
            this.ctx.arc(0, -enemy.h/2, enemy.w/2, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Eyes
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(-5, -enemy.h/2 - 2, 3, 0, Math.PI * 2);
            this.ctx.arc(5, -enemy.h/2 - 2, 3, 0, Math.PI * 2);
            this.ctx.fill();
            
            this.ctx.fillStyle = '#000000';
            this.ctx.beginPath();
            this.ctx.arc(-5, -enemy.h/2 - 2, 1, 0, Math.PI * 2);
            this.ctx.arc(5, -enemy.h/2 - 2, 1, 0, Math.PI * 2);
            this.ctx.fill();
            
            this.ctx.restore();
        });
    },

    drawCheckpoints() {
        this.checkpoints.forEach(checkpoint => {
            const glow = checkpoint.activated ? Math.sin(checkpoint.animFrame * 0.1) * 0.3 + 0.7 : 0.3;
            
            this.ctx.save();
            this.ctx.globalAlpha = glow;
            
            // Checkpoint flag
            this.ctx.fillStyle = checkpoint.activated ? '#4caf50' : '#757575';
            this.ctx.fillRect(checkpoint.x + 5, checkpoint.y, 5, checkpoint.h);
            
            this.ctx.fillStyle = checkpoint.activated ? '#8bc34a' : '#9e9e9e';
            this.ctx.fillRect(checkpoint.x + 10, checkpoint.y, 25, 20);
            
            if (checkpoint.activated) {
                // Sparkles
                for (let i = 0; i < 3; i++) {
                    const sparkleX = checkpoint.x + 20 + Math.sin(checkpoint.animFrame * 0.1 + i) * 15;
                    const sparkleY = checkpoint.y + 10 + Math.cos(checkpoint.animFrame * 0.1 + i) * 10;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(sparkleX, sparkleY, 2, 2);
                }
            }
            
            this.ctx.restore();
        });
    },

    drawParticles() {
        this.particles.forEach(p => {
            this.ctx.fillStyle = p.color;
            this.ctx.globalAlpha = p.life / 60;
            this.ctx.fillRect(p.x, p.y, p.size, p.size);
            this.ctx.globalAlpha = 1;
        });
    },

    drawCharacter() {
        const p = this.player;
        const art = this.characterArt[game.character];
        const frame = p.animFrame;
        const ctx = this.ctx;

        // Invincibility flashing
        if (p.isInvincible && Math.floor(frame / 5) % 2) return;

        let squashFactor = 1 - Math.sin(p.squash * Math.PI) * 0.2;
        let stretchFactor = 1 + Math.sin(p.squash * Math.PI) * 0.2;

        ctx.save();
        ctx.translate(p.x + p.w / 2, p.y + p.h);
        if (p.facing === 'left') ctx.scale(-1, 1);
        ctx.translate(0, -p.h); 
        ctx.scale(stretchFactor, squashFactor);
        ctx.translate(0, p.h);

        let bob = Math.sin(frame * 0.2) * 2;
        let armSwing = Math.sin(frame * 0.4) * 35;
        let legSwing = Math.sin(frame * 0.4) * 45;

        if (p.animState === 'idle') { armSwing /= 4; legSwing = 0; }
        if (p.animState === 'jump' || p.animState === 'fall') {
            bob = 0; armSwing = -30; legSwing = 30;
            if (p.animState === 'fall') { armSwing = 30; legSwing = -30; }
        }
        
        const drawLimb = (x, y, angle, length, width, color1, color2) => {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle * Math.PI / 180);
            ctx.fillStyle = color2;
            ctx.fillRect(-width/2 -1, 0, width+2, -length-1);
            ctx.fillStyle = color1;
            ctx.fillRect(-width/2, 0, width, -length);
            ctx.beginPath(); ctx.arc(0, -length, width/2, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        };
        
        const torsoY = -p.h / 2 + bob, headY = -p.h + 10 + bob * 1.5;
        
        drawLimb(5, torsoY, legSwing, p.h * 0.45, 12, art.pants_s, '#000'); 
        drawLimb(-5, torsoY, armSwing, p.h * 0.4, 10, art.skin_s, '#000');
        
        ctx.fillStyle = art.shirt_s; ctx.fillRect(-16, torsoY-21, 32, 42); 
        ctx.fillStyle = art.shirt; ctx.fillRect(-15, torsoY-20, 30, 40);
        
        drawLimb(-5, torsoY, -legSwing, p.h * 0.45, 12, art.pants, '#000');
        drawLimb(5, torsoY, -armSwing, p.h * 0.4, 10, art.skin, '#000');

        ctx.fillStyle = art.skin_s; ctx.beginPath(); ctx.arc(0, headY+1, 16, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = art.skin; ctx.beginPath(); ctx.arc(0, headY, 15, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = art.hair; ctx.beginPath(); ctx.arc(0, headY-5, 15, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.ellipse(8, headY, 5, 7, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(10, headY, 3, 0, Math.PI * 2); ctx.fill();

        ctx.restore();
    },

    showOverlay(message, showNextLevelBtn = false) {
        const overlay = document.getElementById('minigame-overlay');
        document.getElementById('minigame-message').textContent = message;
        document.getElementById('minigame-start-btn').style.display = showNextLevelBtn ? 'none' : 'inline-block';
        document.getElementById('minigame-next-level-btn').style.display = showNextLevelBtn ? 'inline-block' : 'none';
        overlay.style.display = 'flex';
    },
    
    hideOverlay() { 
        document.getElementById('minigame-overlay').style.display = 'none'; 
    },
    
    endGame(isComplete = false, isReset = false) {
        this.active = false;
        clearInterval(this.gameInterval);
        window.onkeydown = null; window.onkeyup = null;
        if (isReset) return;
        
        if (!isComplete) {
            this.showOverlay(`Game Over! Final Score: ${this.score}`);
        }
    },
    
    updateUI() {
        document.getElementById('minigame-level').textContent = this.level;
        document.getElementById('minigame-tokens').textContent = `${this.tokens} / ${this.goal}`;
        document.getElementById('minigame-score').textContent = this.score;
        document.getElementById('minigame-lives').textContent = '‚ù§Ô∏è'.repeat(this.lives) + 'üñ§'.repeat(3 - this.lives);
    }
};

// --- 2. SORTING GAME ---
const sortingGame = {
    active: false,
    allActivities: {
      boy: {
        closer: [ 
          { emoji: 'üôè', text: "Praying" }, 
          { emoji: 'üßπ', text: "Helping clean" }, 
          { emoji: 'üìñ', text: "Reading Bible story" }, 
          { emoji: 'ü§ó', text: "Sharing toys" } 
        ],
        distraction: [ 
          { emoji: 'üéÆ', text: "Video games all evening" }, 
          { emoji: 'üì∫', text: "Watching TV late" }, 
          { emoji: 'üò†', text: "Arguing" }, 
          { emoji: 'üò´', text: "Complaining" } 
        ]
      },
      girl: {
        closer: [ 
          { emoji: 'üôè', text: "Personal prayer" }, 
          { emoji: 'ü§ù', text: "Helping a friend" }, 
          { emoji: 'üìñ', text: "Personal Bible reading" }, 
          { emoji: 'üìù', text: "Meeting prep" } 
        ],
        distraction: [ 
          { emoji: 'üì±', text: "Hours on social media" }, 
          { emoji: 'üí¨', text: "Gossiping" }, 
          { emoji: 'üëª', text: "Scary movies" }, 
          { emoji: 'ü§î', text: "Worrying about popularity" } 
        ]
      }
    },
    
    start() {
        this.active = true;
        this.loadCards();
    },

    loadCards() {
        const cardContainer = document.getElementById('cards-container');
        cardContainer.innerHTML = '';
        document.getElementById('closer').innerHTML = '<h3>üëç Keeps Me Close to Jehovah</h3>';
        document.getElementById('distraction').innerHTML = '<h3>ü§î Could Be a Distraction</h3>';

        const mode = game.character === 'boy' ? 'boy' : 'girl';
        const activities = [...this.allActivities[mode].closer, ...this.allActivities[mode].distraction];
        activities.sort(() => 0.5 - Math.random());

        activities.forEach((activity, idx) => {
            const card = document.createElement("div");
            card.className = "card";
            card.id = `card${idx}`;
            card.draggable = true;
            card.innerHTML = `<span class="emoji">${activity.emoji}</span><span>${activity.text}</span>`;
            
            const isCloser = this.allActivities[mode].closer.some(c => c.text === activity.text);
            card.dataset.correctZone = isCloser ? 'closer' : 'distraction';
            
            card.ondragstart = (e) => e.dataTransfer.setData("text", e.target.id);
            cardContainer.appendChild(card);
        });
        
        document.querySelectorAll('.dropzone').forEach(zone => {
            zone.ondragover = (e) => e.preventDefault();
            zone.ondrop = this.onDrop;
        });
    },

    onDrop(e) {
        e.preventDefault();
        const cardId = e.dataTransfer.getData("text");
        const card = document.getElementById(cardId);
        let dropzone = e.target;
        while (!dropzone.classList.contains('dropzone')) dropzone = dropzone.parentElement;
        
        if (card.dataset.correctZone === dropzone.id) {
            dropzone.appendChild(card);
            card.draggable = false;
            card.style.borderColor = 'green';
        } else {
            card.style.borderColor = 'red';
            setTimeout(() => card.style.borderColor = '#ccc', 500);
        }
    },
    endGame() { this.active = false; }
};

// --- 3. MEMORY GAME ---
const memoryGame = {
    level: 1, timer: 0, timerId: null, matches: 0, goal: 0,
    isChecking: false, flippedCards: [],
    levelData: [
        { pairs: 4, time: null }, { pairs: 6, time: 90 }, { pairs: 8, time: 120 }
    ],
    
    start() {
        this.resetState();
        const currentLevel = this.levelData[this.level - 1];
        if (!currentLevel) { alert("You've completed all levels!"); resetAndGoHome(); return; }
        
        this.goal = currentLevel.pairs;
        this.timer = currentLevel.time;

        this.updateUI();
        this.createGrid(currentLevel.pairs);
        if (this.timer) this.startTimer();
    },

    createGrid(pairCount) {
        const grid = document.getElementById('memory-game-grid');
        grid.innerHTML = '';
        const columns = pairCount * 2 > 8 ? 4 : 4;
        grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
        
        const activities = [{e:'üôè'}, {e:'üìñ'}, {e:'ü§ù'}, {e:'üòä'}, {e:'üßπ'}, {e:'üé∂'}, {e:'ü§ó'}, {e:'‚ù§Ô∏è'}];
        let cardPool = activities.slice(0, pairCount);
        cardPool = [...cardPool, ...cardPool];
        cardPool.sort(() => 0.5 - Math.random());

        cardPool.forEach(item => {
            const cardEl = document.createElement('div');
            cardEl.classList.add('memory-card');
            cardEl.dataset.id = item.e;
            cardEl.innerHTML = `<div class="card-face card-back">?</div><div class="card-face card-front">${item.e}</div>`;
            cardEl.onclick = () => this.flipCard(cardEl);
            grid.appendChild(cardEl);
        });
    },

    flipCard(cardEl) {
        if (this.isChecking || cardEl.classList.contains('is-flipped') || this.flippedCards.length >= 2) return;
        cardEl.classList.add('is-flipped');
        this.flippedCards.push(cardEl);
        if (this.flippedCards.length === 2) this.checkForMatch();
    },

    checkForMatch() {
        this.isChecking = true;
        const [card1, card2] = this.flippedCards;
        if (card1.dataset.id === card2.dataset.id) {
            this.matches++;
            this.updateUI();
            setTimeout(() => {
                card1.classList.add('is-matched');
                card2.classList.add('is-matched');
                this.flippedCards = [];
                this.isChecking = false;
                if (this.matches === this.goal) this.levelComplete();
            }, 500);
        } else {
            setTimeout(() => {
                card1.classList.remove('is-flipped');
                card2.classList.remove('is-flipped');
                this.flippedCards = [];
                this.isChecking = false;
            }, 1000);
        }
    },
    
    levelComplete() {
        clearInterval(this.timerId);
        alert(`Level ${this.level} Complete!`);
        if (this.level < this.levelData.length) {
            this.level++;
            this.start();
        } else {
            alert("You beat the Memory Game!");
            resetAndGoHome();
        }
    },
    
    startTimer() {
        const timerEl = document.getElementById('memory-timer');
        this.timerId = setInterval(() => {
            this.timer--;
            timerEl.textContent = this.timer;
            if (this.timer <= 0) {
                clearInterval(this.timerId);
                alert("Time's up! Try again.");
                this.start();
            }
        }, 1000);
    },
    
    updateUI() {
        document.getElementById('memory-level').textContent = this.level;
        document.getElementById('memory-matches').textContent = `${this.matches} / ${this.goal}`;
        document.getElementById('memory-timer').textContent = this.timer || '--';
    },

    resetState() {
        this.matches = 0;
        this.isChecking = false;
        this.flippedCards = [];
        if (this.timerId) clearInterval(this.timerId);
        this.timerId = null;
    }
};

// --- INITIALIZATION & EVENT LISTENERS ---
window.onload = () => {
    document.getElementById('start-sorting-btn').onclick = () => {
        switchScreen('sorting-game-screen');
        sortingGame.start();
    };
    document.getElementById('start-memory-btn').onclick = () => {
        switchScreen('memory-game-screen');
        memoryGame.level = 1;
        memoryGame.start();
    };
    document.getElementById('start-minigame-btn').onclick = () => {
        switchScreen('minigame-screen');
        platformFighter.init();
    };
    document.getElementById('character-selector').onchange = (e) => {
        game.character = e.target.value;
    };
};
</script>
</body>
</html>

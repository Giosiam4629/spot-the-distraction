<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spot the Distraction - Adventure Edition</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Comic+Neue:wght@400;700&display=swap">
  <style>
    :root {
      --bg-color: #eaf5ff;
      --panel-bg: #ffffff;
      --primary-text: #3d5a80;
      --accent-green: #2a9d8f;
      --accent-red: #e76f51;
      --accent-orange: #f4a261;
      --font-header: 'Fredoka One', cursive;
      --font-body: 'Comic Neue', sans-serif;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
    }

    /* --- General Setup --- */
    body {
      font-family: var(--font-body);
      background-color: var(--bg-color);
      color: var(--primary-text);
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .main-container {
      width: 100%;
      max-width: 900px;
    }
    .panel {
      background-color: var(--panel-bg);
      border-radius: 20px;
      padding: 20px 30px;
      box-shadow: var(--shadow);
      margin-bottom: 20px;
    }
    h2, h3 {
      font-family: var(--font-header);
      color: var(--primary-text);
      margin-top: 0;
    }

    /* --- Screens --- */
    .screen { display: none; }
    .screen.active { display: block; }
    
    /* --- Home/Reset Button --- */
    #home-reset-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      background-color: var(--accent-orange);
      color: white;
      font-size: 1.8rem;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      transition: transform 0.2s ease, background-color 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #home-reset-btn:hover {
      transform: scale(1.1);
      background-color: #e76f51;
    }

    /* --- Game Controls Panel --- */
    #game-controls h2 {
      font-size: 1.2rem;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .control-section {
      margin-bottom: 20px;
      border-top: 1px solid #eee;
      padding-top: 15px;
    }
    .options-group {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }
    .options-group input[type="radio"] { display: none; }
    .options-group label {
      padding: 8px 15px;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      font-weight: bold;
      background-color: #f0f0f0;
    }
    .options-group input[type="radio"]:checked + label {
      background-color: var(--accent-orange);
      color: white;
      transform: scale(1.1);
    }
    #game-progress-bar {
      width: 100%;
      height: 20px;
      background-color: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
    }
    #game-progress-fill {
      width: 0%;
      height: 100%;
      background-color: var(--accent-green);
      transition: width 0.5s ease;
    }
    .stats-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    .stat-box {
      background-color: #f7f9fc;
      border-radius: 10px;
      padding: 10px 20px;
      font-family: var(--font-header);
      font-size: 1.2rem;
      min-width: 100px;
      text-align: center;
    }
    
    /* --- Sorting Game --- */
    .drop-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    @media (max-width: 700px) {
      .drop-container { grid-template-columns: 1fr; }
    }
    .dropzone {
      border: 3px dashed #ccc;
      min-height: 200px;
      padding: 15px;
      border-radius: 15px;
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
    }
    #closer { background-color: #e8f5e9; }
    #distraction { background-color: #ffebee; }
    .dropzone.over { transform: scale(1.02); border-color: var(--accent-orange); box-shadow: 0 8px 20px rgba(0,0,0,0.06); }
    #cards-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      min-height: 150px;
      padding: 20px 0;
    }
    .card {
      background-color: var(--panel-bg);
      border: 3px solid #dfe7f1;
      padding: 15px;
      border-radius: 12px;
      cursor: grab;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: var(--shadow);
      transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
      user-select: none;
      touch-action: none;
    }
    .card:hover { transform: translateY(-5px); }
    .card.dragging { opacity: 0.85; transform: rotate(-2deg) scale(1.02); }
    .card .emoji { font-size: 2rem; }
    .card .text { font-weight: 700; }
    .card .tag { font-size: 0.9rem; opacity: 0.7; }
    .card.correct { border-color: var(--accent-green); animation: pop 220ms ease; }
    .card.incorrect { border-color: var(--accent-red); animation: shake 220ms ease; }

    /* Confetti */
    .confetti {
      position: absolute;
      pointer-events: none;
      animation: fall 800ms ease-out forwards;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));
    }

    /* --- Minigame Screen --- */
    #minigame-screen { text-align: center; }
    .minigame-header {
      display: flex;
      justify-content: space-around;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }
    .minigame-stat { font-family: var(--font-header); font-size: 1.2rem; }
    .minigame-stat .hearts { font-size: 1.8rem; letter-spacing: 2px; }
    canvas#minigame-canvas {
      background: linear-gradient(#87CEEB, #90EE90);
      border-radius: 15px;
      box-shadow: var(--shadow);
      margin: 20px 0;
      width: 100%;
      image-rendering: pixelated; /* pixel look */
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
      border: 1px solid #e3ecfb;
    }
    #minigame-start-btn {
      padding: 15px 30px;
      font-size: 1.2rem;
      background-color: var(--accent-orange);
      color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: transform 0.15s ease, filter 0.15s ease;
    }
    #minigame-start-btn:hover { transform: translateY(-1px); filter: brightness(1.05); }
    #minigame-instructions { margin-top: 15px; font-style: italic; }

    /* Buttons */
    .nav-button {
        margin-top: 20px;
        background-color: #6a0dad;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-family: var(--font-header);
    }

    /* Animations */
    @keyframes pop {
      0% { transform: scale(0.95); }
      70% { transform: scale(1.04); }
      100% { transform: scale(1.0); }
    }
    @keyframes shake {
      0%,100% { transform: translateX(0); }
      30% { transform: translateX(-4px); }
      60% { transform: translateX(4px); }
    }
    @keyframes fall {
      0% { transform: translateY(-10px) rotate(0deg); opacity: 1; }
      100% { transform: translateY(60px) rotate(240deg); opacity: 0; }
    }
  </style>
</head>
<body>

<button id="home-reset-btn" title="Reset Game and Go Home">üè†</button>

<div class="main-container">

  <div id="sorting-game-screen" class="screen active">
    <div id="game-controls" class="panel">
      <div class="control-section">
        <h2>üë§ Choose Your Character</h2>
        <div class="options-group" id="character-selector">
          <input type="radio" id="char-cello" name="character" value="cello" checked><label for="char-cello">Cello (7-yr) üë¶</label>
          <input type="radio" id="char-fina" name="character" value="fina"><label for="char-fina">Fina (11-yr) üëß</label>
          <input type="radio" id="char-teen" name="character" value="teen"><label for="char-teen">Teen (15-yr) üë©‚Äçüéì</label>
          <input type="radio" id="char-adult" name="character" value="adult"><label for="char-adult">Adult üë®‚Äçüë©‚Äçüëß‚Äçüë¶</label>
        </div>
      </div>
      <div class="control-section">
        <h2>‚ö° Difficulty Level</h2>
        <div class="options-group" id="difficulty-selector">
          <input type="radio" id="diff-easy" name="difficulty" value="easy" checked><label for="diff-easy">Easy (No Timer) üòä</label>
          <input type="radio" id="diff-medium" name="difficulty" value="medium"><label for="diff-medium">Medium (2 min timer) ‚è∞</label>
          <input type="radio" id="diff-hard" name="difficulty" value="hard"><label for="diff-hard">Hard (1 min timer) üî•</label>
        </div>
      </div>
      <div class="control-section">
        <h2>üìä Game Progress</h2>
        <p>Level: <span id="level-label">1</span> / 5</p>
        <div id="game-progress-bar"><div id="game-progress-fill"></div></div>
      </div>
      <div class="stats-container">
        <div class="stat-box">Score: <span id="score-label">0</span></div>
        <div class="stat-box">Streak: <span id="streak-label">0</span></div>
        <div class="stat-box">Time: <span id="timer-label">--:--</span></div>
      </div>
    </div>
    
    <div class="panel">
      <div class="drop-container">
        <div id="closer" class="dropzone"><h3>üëç Keeps Me Close to Jehovah</h3></div>
        <div id="distraction" class="dropzone"><h3>ü§î Could Be a Distraction</h3></div>
      </div>
      <h3 style="text-align: center;">Drag the Activities</h3>
      <div id="cards-container"></div>
    </div>
    <div style="text-align:center;">
        <button id="switch-to-minigame-btn" class="nav-button">üéÆ Play Side-Scroller Adventure!</button>
    </div>
  </div>

  <div id="minigame-screen" class="screen">
    <div class="panel">
      <h2>üéÆ Advanced Mini-Game: Side-Scroller Adventure!</h2>
      <div class="minigame-header">
        <div class="minigame-stat">Adventure Score: <span id="minigame-score">0</span></div>
        <div class="minigame-stat">Kingdom Tokens: <span id="minigame-tokens">0</span> / 10</div>
        <div class="minigame-stat"><span class="hearts" id="minigame-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
      </div>
      <canvas id="minigame-canvas" width="600" height="300"></canvas>
      <button id="minigame-start-btn">Start Adventure üöÄ</button>
      <div id="minigame-instructions">Use SPACE or ‚Üë to jump. Collect Kingdom Tokens üìñ! Avoid distractions üì∫!</div>
      <button id="switch-to-sorting-btn" class="nav-button" style="background-color:#777;">Back to Sorting Game</button>
    </div>
  </div>

</div>

<script>
// --- GAME STATE ---
const initialGameState = {
    character: 'cello',
    difficulty: 'easy',
    level: 1,
    maxLevels: 5,
    score: 0,
    streak: 0,
    timerId: null,
    timeLeft: 0,
    activeScreen: 'sorting',
    usedCards: new Set()
};
let game = { ...initialGameState };

// --- DOM ELEMENTS ---
const elements = {
    sortingScreen: document.getElementById('sorting-game-screen'),
    minigameScreen: document.getElementById('minigame-screen'),
    characterSelector: document.getElementById('character-selector'),
    difficultySelector: document.getElementById('difficulty-selector'),
    levelLabel: document.getElementById('level-label'),
    progressFill: document.getElementById('game-progress-fill'),
    scoreLabel: document.getElementById('score-label'),
    streakLabel: document.getElementById('streak-label'),
    timerLabel: document.getElementById('timer-label'),
    cardsContainer: document.getElementById('cards-container'),
    dropCloser: document.getElementById('closer'),
    dropDistraction: document.getElementById('distraction')
};

/* ===========================
   ACTIVITIES (CARD POOL)
=========================== */
const ACTIVITY_POOL = [
  { emoji: 'üìñ', text: 'Personal Bible Reading', type: 'closer' },
  { emoji: 'üôè', text: 'Prayer Before Bed', type: 'closer' },
  { emoji: 'üìù', text: 'Prepare for Meeting', type: 'closer' },
  { emoji: 'ü§ù', text: 'Help a Friend', type: 'closer' },
  { emoji: 'üéµ', text: 'Sing Kingdom Songs', type: 'closer' },
  { emoji: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶', text: 'Family Worship Night', type: 'closer' },
  { emoji: 'üìö', text: 'Study Watchtower', type: 'closer' },
  { emoji: 'üïäÔ∏è', text: 'Make Peace with Sibling', type: 'closer' },
  { emoji: 'üíå', text: 'Write Encouraging Note', type: 'closer' },
  { emoji: 'üå±', text: 'Practice a Fruit of the Spirit', type: 'closer' },

  { emoji: 'üì±', text: 'Scroll Social Media Forever', type: 'distraction' },
  { emoji: 'üéÆ', text: 'Game All Night', type: 'distraction' },
  { emoji: 'üõçÔ∏è', text: 'Buy Stuff You Don‚Äôt Need', type: 'distraction' },
  { emoji: 'üç≠', text: 'Candy Before Dinner', type: 'distraction' },
  { emoji: 'üò¥', text: 'Oversleep on Purpose', type: 'distraction' },
  { emoji: 'üí¨', text: 'Gossip About Classmates', type: 'distraction' },
  { emoji: 'üì∫', text: 'Binge Shows Instead of Study', type: 'distraction' },
  { emoji: 'üò°', text: 'Stay Mad All Day', type: 'distraction' },
  { emoji: 'üí∏', text: 'Worry Only About Money', type: 'distraction' },
  { emoji: 'üçü', text: 'Junk Food Marathon', type: 'distraction' },

  // extra variety
  { emoji: 'üåü', text: 'Share Something Encouraging', type: 'closer' },
  { emoji: 'üßπ', text: 'Help Clean the House', type: 'closer' },
  { emoji: 'üìî', text: 'Gratitude Journal', type: 'closer' },
  { emoji: 'üéâ', text: 'Party Till Homework Time', type: 'distraction' },
  { emoji: 'üåÄ', text: 'Internet Rabbit Hole', type: 'distraction' }
];

/* ===========================
   UTILS
=========================== */
function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function formatTime(sec) {
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  return `${m}:${s.toString().padStart(2, '0')}`;
}

/* ===========================
   SORTING GAME CORE
=========================== */
let currentRoundCards = [];
let placedCount = 0;

function getAvailableCards(count = 8) {
  const remaining = ACTIVITY_POOL.filter(c => !game.usedCards.has(c.text));
  if (remaining.length < count) {
    // Soft reset to keep variety once pool is exhausted
    game.usedCards.clear();
    return getAvailableCards(count);
  }
  // Ensure mix of both types
  const closers = shuffle(remaining.filter(c => c.type === 'closer'));
  const dists = shuffle(remaining.filter(c => c.type === 'distraction'));
  const half = Math.floor(count / 2);
  const picks = [
    ...closers.slice(0, half),
    ...dists.slice(0, count - half)
  ];
  picks.forEach(p => game.usedCards.add(p.text));
  return shuffle(picks);
}

function renderCards() {
  elements.cardsContainer.innerHTML = '';
  currentRoundCards.forEach((card, idx) => {
    const el = document.createElement('div');
    el.className = 'card';
    el.draggable = true;
    el.dataset.idx = String(idx);
    el.dataset.type = card.type;
    el.innerHTML = `
      <div class="emoji">${card.emoji}</div>
      <div>
        <div class="text">${card.text}</div>
        <div class="tag">${card.type === 'closer' ? 'Closer' : 'Distraction'}</div>
      </div>
    `;
    addDnDHandlers(el);
    elements.cardsContainer.appendChild(el);
  });
}

function addDnDHandlers(cardEl) {
  cardEl.addEventListener('dragstart', e => {
    cardEl.classList.add('dragging');
    e.dataTransfer.setData('text/plain', cardEl.dataset.idx);
  });
  cardEl.addEventListener('dragend', () => cardEl.classList.remove('dragging'));
}

// Dropzone interactions
['dragover','dragenter'].forEach(evt => {
  elements.dropCloser.addEventListener(evt, e => { e.preventDefault(); elements.dropCloser.classList.add('over'); });
  elements.dropDistraction.addEventListener(evt, e => { e.preventDefault(); elements.dropDistraction.classList.add('over'); });
});
['dragleave','drop'].forEach(evt => {
  elements.dropCloser.addEventListener(evt, () => elements.dropCloser.classList.remove('over'));
  elements.dropDistraction.addEventListener(evt, () => elements.dropDistraction.classList.remove('over'));
});

elements.dropCloser.addEventListener('drop', e => {
  e.preventDefault();
  const idx = e.dataTransfer.getData('text/plain');
  const cardEl = document.querySelector(`.card[data-idx="${idx}"]`);
  if (cardEl) handleDropToZone(cardEl, elements.dropCloser);
});
elements.dropDistraction.addEventListener('drop', e => {
  e.preventDefault();
  const idx = e.dataTransfer.getData('text/plain');
  const cardEl = document.querySelector(`.card[data-idx="${idx}"]`);
  if (cardEl) handleDropToZone(cardEl, elements.dropDistraction);
});

function handleDropToZone(cardEl, zoneEl) {
  const correctType = zoneEl.id === 'closer' ? 'closer' : 'distraction';
  const isCorrect = cardEl.dataset.type === correctType;

  if (isCorrect) {
    cardEl.classList.add('correct');
    burstConfetti(zoneEl);
    game.streak++;
    const gained = 50 + (game.level * 10) + (game.streak * 5);
    game.score += gained;
    placedCount++;
    setTimeout(() => cardEl.remove(), 160);
  } else {
    cardEl.classList.add('incorrect');
    game.streak = 0;
    game.score = Math.max(0, game.score - 20);
    setTimeout(() => cardEl.classList.remove('incorrect'), 240);
  }
  updateSortingUI();
  checkRoundComplete();
}

function burstConfetti(zoneEl) {
  const rect = zoneEl.getBoundingClientRect();
  for (let i = 0; i < 10; i++) {
    const s = document.createElement('div');
    s.className = 'confetti';
    s.style.left = (rect.left + rect.width / 2 + (Math.random() * 60 - 30)) + 'px';
    s.style.top = (rect.top + 10) + 'px';
    s.style.width = s.style.height = (6 + Math.random() * 6) + 'px';
    s.style.background = ['#2a9d8f','#f4a261','#e76f51','#3d5a80','#ffd166'][Math.floor(Math.random()*5)];
    s.style.transform = `translateY(0) rotate(${Math.random()*180}deg)`;
    s.style.borderRadius = '2px';
    s.style.position = 'fixed';
    document.body.appendChild(s);
    setTimeout(() => s.remove(), 820);
  }
}

function updateSortingUI() {
  elements.levelLabel.textContent = game.level;
  elements.scoreLabel.textContent = game.score;
  elements.streakLabel.textContent = game.streak;
  const progressPct = Math.min(100, ((game.level - 1) / (game.maxLevels - 1)) * 100);
  elements.progressFill.style.width = progressPct + '%';
}

function startTimerIfNeeded() {
  if (game.difficulty === 'easy') {
    elements.timerLabel.textContent = '--:--';
    if (game.timerId) { clearInterval(game.timerId); game.timerId = null; }
    return;
  }
  game.timeLeft = game.difficulty === 'medium' ? 120 : 60;
  elements.timerLabel.textContent = formatTime(game.timeLeft);
  if (game.timerId) clearInterval(game.timerId);
  game.timerId = setInterval(() => {
    game.timeLeft--;
    elements.timerLabel.textContent = formatTime(Math.max(0, game.timeLeft));
    if (game.timeLeft <= 0) {
      clearInterval(game.timerId);
      endOrNextLevel(true);
    }
  }, 1000);
}

function beginLevel() {
  const cardCount = Math.min(10, 6 + Math.floor((game.level - 1) * 1.5)); // scales up a bit
  placedCount = 0;
  currentRoundCards = getAvailableCards(cardCount);
  renderCards();
  startTimerIfNeeded();
  updateSortingUI();
}

function checkRoundComplete() {
  const remaining = elements.cardsContainer.querySelectorAll('.card').length;
  const threshold = Math.ceil(currentRoundCards.length * 0.7); // finish when 70% placed
  if (placedCount >= threshold || remaining === 0) {
    endOrNextLevel(false);
  }
}

function endOrNextLevel(isTimeout) {
  if (game.timerId) { clearInterval(game.timerId); game.timerId = null; }
  if (isTimeout) {
    game.streak = 0;
    game.score = Math.max(0, game.score - 40);
  } else {
    if (game.difficulty !== 'easy' && game.timeLeft > 0) {
      game.score += game.timeLeft * 2; // time bonus
    }
  }
  updateSortingUI();

  if (game.level >= game.maxLevels) {
    alert(`Level Pack Complete! üéâ\nScore: ${game.score}\nGreat job! Play again to beat your score!`);
    game.level = 1;
    game.usedCards.clear();
  } else {
    game.level++;
  }
  beginLevel();
}

/* ===========================
   PIXEL ART CHARACTERS (Minigame)
=========================== */
const pixelArt = {
  drawFromMap(ctx, x, y, map, size) {
    map.pixels.forEach((row, r) => {
      row.forEach((colorKey, c) => {
        if (!map.palette[colorKey]) return;
        ctx.fillStyle = map.palette[colorKey];
        ctx.fillRect(x + c * size, y + r * size, size, size);
      });
    });
  },
  characters: {
    cello: {
      palette: { S: '#f2a66e', s: '#d88c57', H: '#3a2d27', T: '#4a90e2', t: '#3b73b5', P: '#333', p: '#222'},
      run1: [ ' HHH ', ' SSH ', 'SSTT ', ' TTt ', ' P p ' ],
      run2: [ ' HHH ', ' SSH ', 'SSTT ', ' T Tt', ' p P ' ],
      jump: [ ' HHH ', ' SSH ', 'SSTT ', ' TTT ', ' p p ' ]
    },
    fina: {
      palette: { S: '#ffbe87', s: '#e5a36f', H: '#8b572a', h: '#653f1f', D: '#e91e63', d: '#c2185b' },
      run1: [ ' HHHh', 'hSS H', ' SSDD', ' D dD', ' d d' ],
      run2: [ ' HHHh', 'hSS H', ' SSDD', ' D DD', 'd  d' ],
      jump: [ ' HHHh', 'hSS H', ' SSDD', ' dDd ', ' d d ' ]
    }
  },
  drawAnimatedCharacter(ctx, charType, x, y, size, animState, frame) {
    // Map teen/adult to existing styles
    const key = (charType === 'fina') ? 'fina' : 'cello';
    const data = this.characters[key];
    const map = animState === 'jump' ? data.jump : ((frame % 40) < 20 ? data.run1 : data.run2);
    const mapObj = { palette: data.palette, pixels: map.map(r => r.split('')) };
    this.drawFromMap(ctx, x, y, mapObj, size);
  }
};

/* ===========================
   SIDE SCROLLER MINIGAME
=========================== */
const sideScroller = {
    canvas: document.getElementById('minigame-canvas'),
    ctx: null,
    active: false,
    gameInterval: null,
    // State
    score: 0, lives: 3, tokens: 0, goal: 10, frame: 0,
    speed: 3,
    invuln: 0,
    // Game Objects
    player: { x: 50, y: 220, w: 20, h: 20, vy: 0, grounded: true },
    objects: [], // { type, x, y, w, h }
    backgroundLayers: [],
    particles: [],

    init() {
        this.ctx = this.canvas.getContext('2d');
        document.getElementById('minigame-start-btn').onclick = () => this.start();
        document.addEventListener('keydown', e => {
            if ((e.code === 'Space' || e.key === 'ArrowUp') && this.active) this.jump();
        });
        this.canvas.addEventListener('click', () => { if(this.active) this.jump(); });
    },
    start() {
        this.active = true;
        this.lives = 3; this.score = 0; this.tokens = 0; this.frame = 0; this.speed = 3; this.invuln = 0;
        this.player.y = this.canvas.height - 40 - this.player.h;
        this.player.vy = 0; this.player.grounded = true;
        this.objects = [];
        this.particles = [];
        this.backgroundLayers = [
            { speed: 0.2, y: 50, height: 50, color: '#add8e6', objects: [{x: 100, w: 120}, {x: 400, w: 160}] }, // Far clouds
            { speed: 0.5, y: 150, height: 100, color: '#228b22', objects: [{x: 50, w: 220}, {x: 520, w: 180}] }, // Hills
        ];
        if (this.gameInterval) clearInterval(this.gameInterval);
        this.gameInterval = setInterval(() => this.loop(), 1000 / 60);
        this.updateUI();
    },
    endGame(isReset = false) {
        this.active = false;
        clearInterval(this.gameInterval);
        if (isReset) return;
        this.overlay(this.tokens >= this.goal ? "You Win! Great job!" : "Game Over. Try Again!");
    },
    overlay(text) {
        this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = 'white';
        this.ctx.font = '24px Fredoka One';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(text, this.canvas.width / 2, this.canvas.height / 2);
    },
    jump() {
        if (this.player.grounded) {
            this.player.vy = -16;
            this.player.grounded = false;
            // jump particles
            for (let i=0;i<6;i++) this.particles.push({x:this.player.x+10, y:this.player.y+this.player.h, vx:(Math.random()*2-1)*1.5, vy:-Math.random()*2, life:18, color:'#94a3b8'});
        }
    },
    spawn() {
        // Tokens (üìñ): ~every 70 frames with chance
        if (this.frame % 70 === 0 && Math.random() < 0.65) {
            this.objects.push({
                type: 'token',
                x: this.canvas.width + 10,
                y: 70 + Math.random() * 120,
                w: 16, h: 16
            });
        }
        // Hazards (üì∫): ~every 90 frames with chance
        if (this.frame % 90 === 0 && Math.random() < 0.75) {
            this.objects.push({
                type: 'hazard',
                x: this.canvas.width + 10,
                y: this.canvas.height - 40 - 18,
                w: 22, h: 18
            });
        }
    },
    collide(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    },
    loop() {
        if (!this.active) return;
        this.frame++;

        // Physics
        this.player.vy += 0.8; // Gravity
        this.player.y += this.player.vy;
        if (this.player.y >= this.canvas.height - 40 - this.player.h) {
            this.player.y = this.canvas.height - 40 - this.player.h;
            this.player.vy = 0;
            this.player.grounded = true;
        }

        // Spawn & move
        this.spawn();
        this.objects.forEach(o => o.x -= this.speed);
        this.objects = this.objects.filter(o => o.x > -50);

        // Collisions
        if (this.invuln > 0) this.invuln--;
        for (let i = this.objects.length - 1; i >= 0; i--) {
            const obj = this.objects[i];
            if (this.collide(this.player, obj)) {
                if (obj.type === 'token') {
                    this.tokens++;
                    this.score += 20 + Math.floor(this.speed);
                    // token particles
                    for (let k=0;k<6;k++) this.particles.push({x:obj.x+obj.w/2, y:obj.y+obj.h/2, vx:(Math.random()*2-1)*1.8, vy:(Math.random()*-2)-0.5, life:22, color:'#facc15'});
                    this.objects.splice(i,1);
                } else if (obj.type === 'hazard' && this.invuln === 0) {
                    this.lives--;
                    this.invuln = 40; // brief invulnerability
                    this.screenShake(6, 10);
                    this.objects.splice(i,1);
                    if (this.lives <= 0) {
                        this.updateUI();
                        this.endGame();
                        return;
                    }
                }
            }
        }

        // Difficulty ramp
        if (this.frame % 300 === 0 && this.speed < 7) this.speed += 0.2;
        this.score++; // distance score

        // --- Drawing ---
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawBackground();
        this.drawObjects();

        // Draw player (animated)
        const animState = this.player.grounded ? 'run' : 'jump';
        pixelArt.drawAnimatedCharacter(this.ctx, game.character, this.player.x, this.player.y, 3, animState, this.frame);

        // Particles
        this.drawParticles();

        this.updateUI();
        if (this.tokens >= this.goal) {
          this.endGame();
        }
    },
    drawBackground() {
        // Parallax Layers
        this.backgroundLayers.forEach(layer => {
            this.ctx.fillStyle = layer.color;
            layer.objects.forEach(obj => {
                let objX = (obj.x - (this.frame * layer.speed)) % (this.canvas.width + obj.w);
                if (objX < -obj.w) objX += (this.canvas.width + obj.w);
                this.ctx.fillRect(objX, layer.y, obj.w, layer.height);
            });
        });
        // Ground
        this.ctx.fillStyle = '#556b2f';
        this.ctx.fillRect(0, this.canvas.height - 40, this.canvas.width, 40);
        this.ctx.fillStyle = 'rgba(255,255,255,0.15)';
        for (let x = 0; x < this.canvas.width; x += 24) {
          this.ctx.fillRect(x, this.canvas.height - 20, 16, 4);
        }
    },
    drawObjects() {
        this.objects.forEach(o => {
            if (o.type === 'token') {
                // token
                this.ctx.fillStyle = '#facc15';
                this.ctx.fillRect(Math.round(o.x), Math.round(o.y), o.w, o.h);
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('üìñ', Math.round(o.x + o.w/2), Math.round(o.y + o.h/2 + 3));
            } else {
                // hazard (TV)
                this.ctx.fillStyle = '#4b5563';
                this.ctx.fillRect(Math.round(o.x), Math.round(o.y), o.w, o.h);
                this.ctx.fillStyle = '#cbd5e1';
                this.ctx.fillRect(Math.round(o.x+3), Math.round(o.y+3), o.w-6, o.h-8);
                this.ctx.fillStyle = '#ef4444';
                this.ctx.fillRect(Math.round(o.x+o.w-5), Math.round(o.y+2), 3, 3);
            }
        });
    },
    drawParticles() {
        this.particles.forEach(p => {
          p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life--;
          this.ctx.fillStyle = p.color;
          this.ctx.fillRect(Math.round(p.x), Math.round(p.y), 3, 3);
        });
        this.particles = this.particles.filter(p => p.life > 0);
    },
    screenShake(intensity=5, frames=8) {
      const original = this.canvas.style.transform || '';
      let i = 0;
      const sh = setInterval(() => {
        const dx = (Math.random()*2-1)*intensity;
        const dy = (Math.random()*2-1)*intensity;
        this.canvas.style.transform = `translate(${dx}px, ${dy}px)`;
        if (++i >= frames) {
          clearInterval(sh);
          this.canvas.style.transform = original;
        }
      }, 16);
    },
    updateUI() {
        document.getElementById('minigame-score').textContent = this.score;
        document.getElementById('minigame-tokens').textContent = this.tokens;
        document.getElementById('minigame-lives').textContent = '‚ù§Ô∏è'.repeat(this.lives) + 'üñ§'.repeat(Math.max(0, 3 - this.lives));
    }
};

// --- UI AND EVENT HANDLERS ---
function switchScreen(screenName) {
    elements.sortingScreen.classList.toggle('active', screenName === 'sorting');
    elements.minigameScreen.classList.toggle('active', screenName === 'minigame');
    game.activeScreen = screenName;
    if (sideScroller.active) {
        sideScroller.endGame(true); // End game on screen switch without message
    }
}

function updateUIFromState() {
    // Reset radio buttons
    document.getElementById(`char-${game.character}`).checked = true;
    document.getElementById(`diff-${game.difficulty}`).checked = true;
    
    // Reset labels and progress
    elements.levelLabel.textContent = game.level;
    elements.scoreLabel.textContent = game.score;
    elements.streakLabel.textContent = game.streak;
    elements.timerLabel.textContent = '--:--';
    elements.progressFill.style.width = '0%';
}

function resetAndGoHome() {
    // Stop any active games
    if (sideScroller.active) {
        sideScroller.endGame(true);
    }
    if (game.timerId) {
        clearInterval(game.timerId);
    }
    
    // Reset game state
    game = { ...initialGameState };
    
    // Update UI to reflect reset state
    updateUIFromState();
    
    // Go to the main screen
    switchScreen('sorting');
    beginLevel();
}

document.getElementById('switch-to-minigame-btn').onclick = () => switchScreen('minigame');
document.getElementById('switch-to-sorting-btn').onclick = () => switchScreen('sorting');
document.getElementById('home-reset-btn').onclick = resetAndGoHome;

elements.characterSelector.addEventListener('change', (e) => {
  if (e.target && e.target.name === 'character') {
    game.character = e.target.value;
  }
});
elements.difficultySelector.addEventListener('change', (e) => {
  if (e.target && e.target.name === 'difficulty') {
    game.difficulty = e.target.value;
    if (game.activeScreen === 'sorting') {
      if (game.timerId) clearInterval(game.timerId);
      startTimerIfNeeded();
    }
  }
});

/* ===========================
   INITIALIZE
=========================== */
window.onload = () => {
    sideScroller.init();
    updateUIFromState(); // Set initial UI
    beginLevel();
};
</script>
</body>
</html>

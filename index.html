<script>
// --- GLOBAL & MENU LOGIC ---
const initialGameState = { character: 'boy' };
let game = { ...initialGameState };

function switchScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
    
    if (platformFighter.active) platformFighter.endGame(false, true);
    if (memoryGame.timerId) clearInterval(memoryGame.timerId);
    if (sortingGame.active) sortingGame.endGame();
}

function resetAndGoHome() {
    game = { ...initialGameState };
    document.getElementById(`char-${game.character}`).checked = true;
    switchScreen('main-menu-screen');
}

document.getElementById('home-reset-btn').onclick = resetAndGoHome;


// --- 1. PLATFORM ADVENTURE MINIGAME ---

// Simple sound generator using Web Audio API (no audio files needed)
const sound = {
    audioCtx: null,
    init() {
        if (this.audioCtx) return;
        try { this.audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        catch (e) { console.error("Web Audio API is not supported in this browser"); }
    },
    play(freq, duration, type = 'sine') {
        if (!this.audioCtx) return;
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.00001, this.audioCtx.currentTime + duration);
        osc.start(this.audioCtx.currentTime);
        osc.stop(this.audioCtx.currentTime + duration);
    },
    jump: function() { this.play(440, 0.1, 'square'); },
    collect: function() { this.play(880, 0.15, 'triangle'); },
    hurt: function() { this.play(220, 0.3, 'sawtooth'); },
    powerup: function() { this.play(660, 0.2, 'sine'); },
    levelComplete: function() { this.play(1000, 0.5, 'sine'); }
};

// Data for all game levels
const levelDesigns = [
    {}, // Level 0 placeholder
    { // Level 1
        goal: { x: 2200, y: 300, w: 50, h: 100 },
        platforms: [
            { x: -100, y: 400, w: 800, h: 50 },
            { x: 850, y: 320, w: 150, h: 30 },
            { x: 1100, y: 250, w: 150, h: 30 },
            { x: 850, y: 180, w: 100, h: 30 },
            { x: 1400, y: 400, w: 900, h: 50 },
        ],
        movingPlatforms: [],
        enemies: [{ x: 500, y: 360, w: 40, h: 40, startX: 500, endX: 650, speed: 1.5 }],
        tokens: [ {x: 875, y: 280}, {x: 1125, y: 210}, {x: 875, y: 140}, {x: 1600, y: 350}, {x: 1800, y: 350} ],
        checkpoints: [],
        powerups: [],
        tokenGoal: 5
    },
    { // Level 2
        goal: { x: 3000, y: 300, w: 50, h: 100 },
        platforms: [
            { x: -100, y: 400, w: 500, h: 50 },
            { x: 800, y: 300, w: 150, h: 30 },
            { x: 1400, y: 180, w: 100, h: 30 },
            { x: 2000, y: 400, w: 1100, h: 50 }
        ],
        movingPlatforms: [
            { x: 500, y: 400, w: 150, h: 30, startX: 500, endX: 750, speed: 2 },
            { x: 1600, y: 400, w: 120, h: 30, startX: 1600, endX: 1900, speed: 2.5 }
        ],
        enemies: [
            { x: 2100, y: 360, w: 40, h: 40, startX: 2100, endX: 2300, speed: 2 },
            { x: 2500, y: 360, w: 40, h: 40, startX: 2500, endX: 2700, speed: 2.5 }
        ],
        tokens: [ {x: 825, y: 260}, {x: 600, y: 300}, {x: 1425, y: 140}, {x: 1750, y: 300}, {x: 2600, y: 300} ],
        checkpoints: [{ x: 1800, y: 340, w: 40, h: 60, activated: false }],
        powerups: [{ x: 2800, y: 360, w: 30, h: 30, type: 'doubleJump' }],
        tokenGoal: 5
    }
];

const platformFighter = {
    canvas: document.getElementById('minigame-canvas'),
    ctx: null, active: false, gameInterval: null, frame: 0,
    level: 1, lives: 3, tokens: 0,
    
    player: {}, // Player object will be reset on start
    platforms: [], enemies: [], tokens: [], movingPlatforms: [], checkpoints: [], powerups: [], goal: {},
    particles: [], gravity: 0.8, camera: { x: 0 },

    characterArt: {
        boy: { skin: '#f2a66e', skin_s: '#d88c57', hair: '#3a2d27', shirt: '#4a90e2', shirt_s: '#3b73b5', pants: '#333', pants_s: '#222' },
        girl: { skin: '#ffbe87', skin_s: '#e5a36f', hair: '#8b572a', shirt: '#e91e63', shirt_s: '#c2185b', pants: '#555', pants_s: '#444' }
    },
    
    init() {
        this.ctx = this.canvas.getContext('2d');
        sound.init();
        document.getElementById('minigame-start-btn').onclick = () => this.start();
        document.getElementById('minigame-next-level-btn').onclick = () => { this.level++; this.start(); };
        this.showOverlay("Platform Adventure");
    },

    start() {
        this.hideOverlay();
        this.active = true;
        this.frame = 0;
        this.lives = 3;
        this.tokens = 0;
        this.camera.x = 0;
        this.particles = [];
        this.resetPlayer();
        this.loadLevel();
        if (this.gameInterval) clearInterval(this.gameInterval);
        this.gameInterval = setInterval(() => this.loop(), 1000 / 60);
        this.addKeyListeners();
    },
    
    resetPlayer() {
        this.player = {
            x: 100, y: 300, w: 40, h: 60, vx: 0, vy: 0,
            speed: 5, jumpPower: 16,
            grounded: false, jumps: 1, maxJumps: 1,
            isInvincible: false, invincibleTimer: 0,
            powerupTimer: 0,
            animState: 'idle', animFrame: 0, facing: 'right', squash: 0,
            respawnPos: { x: 100, y: 300 }
        };
    },
    
    loadLevel() {
        const levelData = levelDesigns[this.level];
        if (!levelData) {
            this.endGame(true); // No more levels, game won
            this.showOverlay("You Win! 🎉");
            return;
        }
        this.platforms = JSON.parse(JSON.stringify(levelData.platforms));
        this.movingPlatforms = JSON.parse(JSON.stringify(levelData.movingPlatforms));
        this.enemies = JSON.parse(JSON.stringify(levelData.enemies));
        this.tokens = JSON.parse(JSON.stringify(levelData.tokens)).map(t => ({...t, w: 20, h: 20, collected: false}));
        this.checkpoints = JSON.parse(JSON.stringify(levelData.checkpoints || []));
        this.powerups = JSON.parse(JSON.stringify(levelData.powerups || []));
        this.goal = { ...levelData.goal };
        this.tokenGoal = levelData.tokenGoal;
    },

    keys: {},
    addKeyListeners() {
        this.keys = {};
        window.onkeydown = e => {
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                if (this.player.jumps > 0) {
                    this.player.vy = -this.player.jumpPower;
                    this.player.jumps--;
                    sound.jump();
                    this.spawnParticles(this.player.x + this.player.w / 2, this.player.y + this.player.h, 10, '#f4a261');
                }
            }
            this.keys[e.code] = true;
        };
        window.onkeyup = e => this.keys[e.code] = false;
    },
    
    loop() {
        this.updatePlayer();
        this.updateEnemies();
        this.updateMovingPlatforms();
        this.updateParticles();
        this.updateCamera();
        this.draw();
        this.updateUI();
        this.frame++;
    },
    
    updatePlayer() {
        const p = this.player;
        if (p.squash > 0) p.squash -= 0.1;
        if (p.invincibleTimer > 0) p.invincibleTimer--;
        else p.isInvincible = false;
        
        if (p.powerupTimer > 0) p.powerupTimer--;
        else p.maxJumps = 1; // Reset powerup

        // Horizontal Movement
        if (this.keys.KeyA || this.keys.ArrowLeft) { p.vx = -p.speed; p.facing = 'left'; }
        else if (this.keys.KeyD || this.keys.ArrowRight) { p.vx = p.speed; p.facing = 'right'; }
        else { p.vx = 0; }
        
        p.x += p.vx;
        this.handleCollisions('x');

        // Vertical Movement
        p.vy += this.gravity;
        p.y += p.vy;
        p.grounded = false;
        this.handleCollisions('y');

        // Other Collisions
        this.handleObjectCollisions();
        
        // Fall off map
        if (p.y > this.canvas.height + 100) this.takeDamage();

        // Animation
        p.animFrame++;
        if (!p.grounded) p.animState = p.vy < 0 ? 'jump' : 'fall';
        else if (p.vx !== 0) p.animState = 'run';
        else p.animState = 'idle';
    },

    handleCollisions(axis) {
        const p = this.player;
        const allPlatforms = [...this.platforms, ...this.movingPlatforms];

        allPlatforms.forEach(plat => {
            if (this.checkCollision(p, plat)) {
                if (axis === 'y') {
                    if (p.vy > 0) { // Moving down
                        if (p.y + p.h - p.vy <= plat.y + 1) { // Was above platform last frame
                            p.y = plat.y - p.h;
                            p.vy = 0;
                            if (!p.grounded) {
                                p.squash = 1;
                                this.spawnParticles(p.x + p.w / 2, p.y + p.h, 15, '#f4a261');
                            }
                            p.grounded = true;
                            p.jumps = p.maxJumps;
                        }
                    } else if (p.vy < 0) { // Moving up
                         if (p.y - p.vy >= plat.y + plat.h) {
                            p.y = plat.y + plat.h;
                            p.vy = 0;
                         }
                    }
                }
                if (axis === 'x') {
                    if (p.vx > 0) { // Moving right
                        if (p.x + p.w - p.vx <= plat.x) {
                           p.x = plat.x - p.w;
                        }
                    } else if (p.vx < 0) { // Moving left
                        if (p.x - p.vx >= plat.x + plat.w) {
                           p.x = plat.x + plat.w;
                        }
                    }
                }
            }
        });
        
        // Add moving platform velocity to player
        if (p.grounded) {
            this.movingPlatforms.forEach(plat => {
                let tempPlayer = { ...p, y: p.y + 1, h: 1 }; // Check slightly below player
                if (this.checkCollision(tempPlayer, plat)) {
                    p.x += plat.vx || 0;
                }
            });
        }
    },
    
    handleObjectCollisions() {
        // Enemies
        this.enemies.forEach(e => {
            if (!this.player.isInvincible && this.checkCollision(this.player, e)) this.takeDamage();
        });
        // Tokens
        this.tokens.forEach(t => {
            if (!t.collected && this.checkCollision(this.player, t)) {
                t.collected = true;
                this.tokens++;
                sound.collect();
                this.spawnParticles(t.x + t.w/2, t.y + t.h/2, 20, 'gold');
            }
        });
        // Checkpoints
        this.checkpoints.forEach(c => {
            if (!c.activated && this.checkCollision(this.player, c)) {
                c.activated = true;
                this.player.respawnPos = { x: c.x, y: c.y - this.player.h };
                sound.powerup();
            }
        });
        // Powerups
        this.powerups.forEach((p, i) => {
            if(this.checkCollision(this.player, p)) {
                if(p.type === 'doubleJump') {
                    this.player.maxJumps = 2;
                    this.player.jumps = 2; // give them the jumps immediately
                    this.player.powerupTimer = 600; // 10 seconds
                }
                this.powerups.splice(i, 1);
                sound.powerup();
            }
        });
        // Goal
        if (this.tokens >= this.tokenGoal && this.checkCollision(this.player, this.goal)) {
            sound.levelComplete();
            if (this.level < levelDesigns.length - 1) {
                this.showOverlay(`Level ${this.level} Complete!`, true);
                this.endGame(true, false);
            } else {
                this.showOverlay("You Win! 🎉");
                this.endGame(true, false);
            }
        }
    },
    
    takeDamage() {
        if (this.player.isInvincible) return;
        this.lives--;
        sound.hurt();
        if (this.lives <= 0) {
            this.endGame(false, false);
            this.showOverlay("Game Over");
        } else {
            this.player.isInvincible = true;
            this.player.invincibleTimer = 120; // 2 seconds
            this.player.x = this.player.respawnPos.x;
            this.player.y = this.player.respawnPos.y;
            this.player.vy = 0;
        }
    },
    
    updateEnemies() {
        this.enemies.forEach(e => {
            e.x += e.speed;
            if (e.x < e.startX || e.x + e.w > e.endX) {
                e.speed *= -1;
            }
        });
    },

    updateMovingPlatforms() {
        this.movingPlatforms.forEach(p => {
            p.vx = p.speed;
            p.x += p.vx;
            if (p.x < p.startX || p.x + p.w > p.endX) {
                p.speed *= -1;
            }
        });
    },

    updateCamera() {
        const targetX = this.player.x - this.canvas.width / 3;
        this.camera.x += (targetX - this.camera.x) * 0.1;
        if(this.camera.x < 0) this.camera.x = 0;
    },
    
    spawnParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4 - 2,
                life: Math.random() * 40 + 20,
                color
            });
        }
    },
    updateParticles() {
        this.particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life--;
            if (p.life <= 0) this.particles.splice(i, 1);
        });
    },
    checkCollision(r1, r2) { return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.h + r1.y > r2.y; },

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.save();
        this.ctx.translate(-this.camera.x, 0);
        this.drawBackground();
        [...this.platforms, ...this.movingPlatforms].forEach(p => this.drawPlatform(p));
        this.drawGoal();
        this.drawCheckpoints();
        this.drawPowerups();
        this.tokens.forEach(t => { if (!t.collected) this.drawToken(t); });
        this.enemies.forEach(e => this.drawEnemy(e));
        this.particles.forEach(p => {
            this.ctx.fillStyle = p.color;
            this.ctx.globalAlpha = p.life / 60;
            this.ctx.fillRect(p.x, p.y, 3, 3);
            this.ctx.globalAlpha = 1;
        });
        this.drawCharacter();
        this.ctx.restore();
    },
    
    drawBackground() {
        const ctx = this.ctx;
        ctx.fillStyle = '#f0f8ff'; // Light sky blue
        ctx.fillRect(this.camera.x, 0, this.canvas.width, this.canvas.height);

        // Simple cartoony clouds
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.beginPath();
        ctx.ellipse(200 - this.camera.x * 0.2, 100, 100, 30, 0, 0, Math.PI * 2);
        ctx.ellipse(250 - this.camera.x * 0.2, 80, 80, 25, 0, 0, Math.PI * 2);
        ctx.ellipse(600 - this.camera.x * 0.2, 150, 120, 35, 0, 0, Math.PI * 2);
        ctx.ellipse(680 - this.camera.x * 0.2, 130, 90, 30, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#333';
        ctx.stroke();
    },
    drawPlatform(p) {
        const ctx = this.ctx;
        ctx.fillStyle = '#6D4C41'; // Brown base
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 4;
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.strokeRect(p.x, p.y, p.w, p.h);

        // Grass top
        ctx.fillStyle = '#8BC34A';
        ctx.fillRect(p.x, p.y, p.w, 15); // Thicker grass
        ctx.strokeRect(p.x, p.y, p.w, 15);

        // Add some small grass tufts
        ctx.fillStyle = '#558B2F';
        for (let i = 0; i < p.w; i += 15 + Math.random() * 10) {
            if (i > 5 && i < p.w - 5) {
                ctx.beginPath();
                ctx.moveTo(p.x + i, p.y);
                ctx.lineTo(p.x + i + 5, p.y - 8);
                ctx.lineTo(p.x + i + 10, p.y);
                ctx.fill();
                ctx.stroke();
            }
        }
    },
    drawGoal() {
        const ctx = this.ctx;
        ctx.lineWidth = 4;
        
        ctx.fillStyle = this.tokens >= this.tokenGoal ? 'gold' : '#ccc'; // Brighter gold
        ctx.strokeStyle = '#333';
        ctx.fillRect(this.goal.x, this.goal.y, this.goal.w, this.goal.h);
        ctx.strokeRect(this.goal.x, this.goal.y, this.goal.w, this.goal.h);

        // Draw a bolder flag
        ctx.fillStyle = '#CC0000'; // Red flag
        ctx.beginPath();
        ctx.moveTo(this.goal.x + this.goal.w / 2, this.goal.y);
        ctx.lineTo(this.goal.x + this.goal.w / 2 + 30, this.goal.y + 15);
        ctx.lineTo(this.goal.x + this.goal.w / 2, this.goal.y + 30);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = 'white';
        ctx.font = 'bold 24px Fredoka One';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('GOAL', this.goal.x + this.goal.w / 2, this.goal.y + this.goal.h / 2 + 30);
        ctx.strokeText('GOAL', this.goal.x + this.goal.w / 2, this.goal.y + this.goal.h / 2 + 30);
    },
    drawToken(t) {
        const ctx = this.ctx;
        ctx.lineWidth = 3;
        
        // Gold coin with a star
        ctx.fillStyle = 'gold';
        ctx.strokeStyle = '#c78d00'; // Darker gold outline
        ctx.beginPath();
        ctx.arc(t.x + t.w/2, t.y + t.h/2, t.w/2 + 2, 0, Math.PI * 2); // Thicker outer outline
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(t.x + t.w/2, t.y + t.h/2, t.w/2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Draw a star inside
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        const outerRadius = t.w / 3;
        const innerRadius = t.w / 6;
        for (let i = 0; i < 5; i++) {
            const angle1 = Math.PI / 2 + i * 2 * Math.PI / 5;
            const angle2 = Math.PI / 2 + (i * 2 + 1) * Math.PI / 5;
            ctx.lineTo(t.x + t.w/2 + outerRadius * Math.sin(angle1), t.y + t.h/2 - outerRadius * Math.cos(angle1));
            ctx.lineTo(t.x + t.w/2 + innerRadius * Math.sin(angle2), t.y + t.h/2 - innerRadius * Math.cos(angle2));
        }
        ctx.closePath();
        ctx.fill();
    },
    drawEnemy(e) {
        const ctx = this.ctx;
        ctx.lineWidth = 3;

        // A simple bouncing blob enemy with eyes
        ctx.fillStyle = '#FF6347'; // Tomato red
        ctx.strokeStyle = '#333';
        ctx.beginPath();
        ctx.arc(e.x + e.w / 2, e.y + e.h / 2, e.w / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Eyes
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(e.x + e.w * 0.35, e.y + e.h * 0.35, e.w * 0.15, 0, Math.PI * 2);
        ctx.arc(e.x + e.w * 0.65, e.y + e.h * 0.35, e.w * 0.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(e.x + e.w * 0.35 + 2, e.y + e.h * 0.35 + 2, e.w * 0.08, 0, Math.PI * 2);
        ctx.arc(e.x + e.w * 0.65 + 2, e.y + e.h * 0.35 + 2, e.w * 0.08, 0, Math.PI * 2);
        ctx.fill();

        // Mouth
        ctx.beginPath();
        ctx.arc(e.x + e.w / 2, e.y + e.h * 0.65, e.w * 0.2, 0, Math.PI, false);
        ctx.stroke();
    },
    drawCheckpoints() {
        const ctx = this.ctx;
        ctx.lineWidth = 3;
        this.checkpoints.forEach(c => {
            ctx.fillStyle = c.activated ? 'rgba(76, 175, 80, 0.8)' : 'rgba(100, 100, 100, 0.6)'; // Green when activated
            ctx.strokeStyle = '#333';
            ctx.fillRect(c.x, c.y, c.w, c.h);
            ctx.strokeRect(c.x, c.y, c.w, c.h);

            // Draw a more stylized flag
            ctx.fillStyle = c.activated ? '#4CAF50' : '#888';
            ctx.beginPath();
            ctx.moveTo(c.x + c.w / 2, c.y);
            ctx.lineTo(c.x + c.w / 2 + 20, c.y + 10);
            ctx.lineTo(c.x + c.w / 2, c.y + 20);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px Fredoka One';
            ctx.textAlign = 'center';
            ctx.fillText('CP', c.x + c.w / 2, c.y + 40);
            ctx.strokeText('CP', c.x + c.w / 2, c.y + 40);
        });
    },
    drawPowerups() {
        const ctx = this.ctx;
        ctx.lineWidth = 3;
        this.powerups.forEach(p => {
            ctx.fillStyle = '#9C27B0'; // Purple
            ctx.strokeStyle = '#333';
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.strokeRect(p.x, p.y, p.w, p.h);

            // Draw a stylized "J+"
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Fredoka One';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('J+', p.x + p.w / 2, p.y + p.h / 2 + 2);
            ctx.strokeText('J+', p.x + p.w / 2, p.y + p.h / 2 + 2);
        });
    },
    drawCharacter() {
        if (this.player.isInvincible && this.frame % 10 < 5) return;
        const p = this.player;
        const art = this.characterArt[game.character];
        const frame = p.animFrame;
        const ctx = this.ctx;

        ctx.save();
        ctx.translate(p.x + p.w / 2, p.y + p.h);
        if (p.facing === 'left') ctx.scale(-1, 1);
        ctx.translate(0, -p.h); // Adjust origin for drawing

        // Apply squash/stretch directly to player dimensions for cartoony effect
        let displayW = p.w * (1 + Math.sin(p.squash * Math.PI) * 0.2);
        let displayH = p.h * (1 - Math.sin(p.squash * Math.PI) * 0.2);

        // Center the scaled character
        ctx.translate(-displayW / 2, -displayH + p.h); 
        
        ctx.lineWidth = 4; // Thicker outline for character
        ctx.strokeStyle = '#333';

        let bob = Math.sin(frame * 0.2) * 2;
        let armSwing = Math.sin(frame * 0.4) * 35;
        let legSwing = Math.sin(frame * 0.4) * 45;

        if (p.animState === 'idle') { armSwing /= 4; legSwing = 0; }
        if (p.animState === 'jump' || p.animState === 'fall') {
            bob = 0; armSwing = -30; legSwing = 30;
            if (p.animState === 'fall') { armSwing = 30; legSwing = -30; }
        }
        
        // --- Custom Cartoony Character Drawing ---
        const drawRoundedRect = (x, y, w, h, r, fill, stroke) => {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            if (fill) { ctx.fillStyle = fill; ctx.fill(); }
            if (stroke) { ctx.strokeStyle = stroke; ctx.stroke(); }
        };

        // Torso
        const torsoW = displayW * 0.8;
        const torsoH = displayH * 0.7;
        const torsoX = (displayW - torsoW) / 2;
        const torsoY = displayH - torsoH + bob;
        drawRoundedRect(torsoX, torsoY, torsoW, torsoH, 8, art.shirt, '#333');

        // Head (large and round)
        const headRadius = displayW * 0.4;
        const headX = displayW / 2;
        const headY = torsoY - headRadius + bob * 1.5 - 5;
        ctx.beginPath();
        ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
        ctx.fillStyle = art.skin; ctx.fill();
        ctx.stroke();

        // Hair (simple blob on top)
        ctx.beginPath();
        ctx.arc(headX, headY - headRadius / 2, headRadius * 0.9, Math.PI * 1.2, Math.PI * 1.8);
        ctx.lineTo(headX + headRadius * 0.9, headY - headRadius / 2);
        ctx.fillStyle = art.hair; ctx.fill();
        ctx.stroke();

        // Eyes (larger, cartoon style)
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.ellipse(headX - headRadius * 0.3, headY - headRadius * 0.1, 7, 10, 0, 0, Math.PI * 2);
        ctx.ellipse(headX + headRadius * 0.3, headY - headRadius * 0.1, 7, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(headX - headRadius * 0.3 + 2, headY - headRadius * 0.1 + 2, 4, 0, Math.PI * 2);
        ctx.arc(headX + headRadius * 0.3 + 2, headY - headRadius * 0.1 + 2, 4, 0, Math.PI * 2);
        ctx.fill();

        // Mouth (simple curve)
        ctx.beginPath();
        ctx.arc(headX, headY + headRadius * 0.3, headRadius * 0.3, 0, Math.PI);
        ctx.stroke();


        // Arms and Legs (simple rectangles, can be rotated)
        const limbW = 10;
        const limbL = displayH * 0.3;

        // Right Arm
        ctx.save();
        ctx.translate(torsoX + torsoW, torsoY + torsoH * 0.2);
        ctx.rotate(armSwing * Math.PI / 180);
        drawRoundedRect(-limbW/2, 0, limbW, limbL, 5, art.shirt, '#333');
        ctx.restore();

        // Left Arm
        ctx.save();
        ctx.translate(torsoX, torsoY + torsoH * 0.2);
        ctx.rotate(-armSwing * Math.PI / 180);
        drawRoundedRect(-limbW/2, 0, limbW, limbL, 5, art.shirt, '#333');
        ctx.restore();

        // Right Leg
        ctx.save();
        ctx.translate(torsoX + torsoW * 0.7, torsoY + torsoH - 5);
        ctx.rotate(legSwing * Math.PI / 180);
        drawRoundedRect(-limbW/2, 0, limbW, limbL, 5, art.pants, '#333');
        ctx.restore();

        // Left Leg
        ctx.save();
        ctx.translate(torsoX + torsoW * 0.3, torsoY + torsoH - 5);
        ctx.rotate(-legSwing * Math.PI / 180);
        drawRoundedRect(-limbW/2, 0, limbW, limbL, 5, art.pants, '#333');
        ctx.restore();

        ctx.restore(); // Restore character translation and scaling
    },

    showOverlay(message, showNextLevelBtn = false) {
        const overlay = document.getElementById('minigame-overlay');
        document.getElementById('minigame-message').textContent = message;
        document.getElementById('minigame-start-btn').style.display = showNextLevelBtn ? 'none' : 'inline-block';
        document.getElementById('minigame-next-level-btn').style.display = showNextLevelBtn ? 'inline-block' : 'none';
        overlay.style.display = 'flex';
    },
    hideOverlay() { 
        document.getElementById('minigame-overlay').style.display = 'none'; 
    },
    endGame(isComplete = false, isReset = false) {
        this.active = false;
        clearInterval(this.gameInterval);
        window.onkeydown = null; window.onkeyup = null;
        if (isReset) return;
        if (!isComplete) this.showOverlay("Game Over");
    },
    updateUI() {
        const levelData = levelDesigns[this.level];
        if(!levelData) return;
        document.getElementById('minigame-level').textContent = this.level;
        document.getElementById('minigame-tokens').textContent = `${this.tokens} / ${levelData.tokenGoal}`;
        document.getElementById('minigame-lives').textContent = '❤️'.repeat(this.lives) + '🖤'.repeat(Math.max(0, 3 - this.lives));
    }
};

// --- 2. SORTING GAME ---
const sortingGame = {
    active: false,
    allActivities: {
      boy: { // Formerly 'cello'
        closer: [ { emoji: '🙏', text: "Praying" }, { emoji: '🧹', text: "Helping clean" }, { emoji: '📖', text: "Reading Bible story" }, { emoji: '🤗', text: "Sharing toys" } ],
        distraction: [ { emoji: '🎮', text: "Video games all evening" }, { emoji: '📺', text: "Watching TV late" }, { emoji: '😠', text: "Arguing" }, { emoji: '😫', text: "Complaining" } ]
      },
      girl: { // Formerly 'fina'
        closer: [ { emoji: '🙏', text: "Personal prayer" }, { emoji: '🤝', text: "Helping a friend" }, { emoji: '📖', text: "Personal Bible reading" }, { emoji: '📝', text: "Meeting prep" } ],
        distraction: [ { emoji: '📱', text: "Hours on social media" }, { emoji: ' gossip', text: "Gossiping" }, { emoji: '👻', text: "Scary movies" }, { emoji: '🤔', text: "Worrying about popularity" } ]
      }
    },
    
    start() {
        this.active = true;
        this.loadCards();
    },

    loadCards() {
        const cardContainer = document.getElementById('cards-container');
        cardContainer.innerHTML = '';
        document.getElementById('closer').innerHTML = '<h3>👍 Keeps Me Close to Jehovah</h3>';
        document.getElementById('distraction').innerHTML = '<h3>🤔 Could Be a Distraction</h3>';

        const mode = game.character === 'boy' ? 'boy' : 'girl';
        const activities = [...this.allActivities[mode].closer, ...this.allActivities[mode].distraction];
        activities.sort(() => 0.5 - Math.random()); // Shuffle

        activities.forEach((activity, idx) => {
            const card = document.createElement("div");
            card.className = "card";
            card.id = `card${idx}`;
            card.draggable = true;
            card.innerHTML = `<span class="emoji">${activity.emoji}</span><span>${activity.text}</span>`;
            
            const isCloser = this.allActivities[mode].closer.some(c => c.text === activity.text);
            card.dataset.correctZone = isCloser ? 'closer' : 'distraction';
            
            card.ondragstart = (e) => e.dataTransfer.setData("text", e.target.id);
            cardContainer.appendChild(card);
        });
        
        document.querySelectorAll('.dropzone').forEach(zone => {
            zone.ondragover = (e) => e.preventDefault();
            zone.ondrop = this.onDrop;
        });
    },

    onDrop(e) {
        e.preventDefault();
        const cardId = e.dataTransfer.getData("text");
        const card = document.getElementById(cardId);
        let dropzone = e.target;
        while (!dropzone.classList.contains('dropzone')) dropzone = dropzone.parentElement;
        
        if (card.dataset.correctZone === dropzone.id) {
            dropzone.appendChild(card);
            card.draggable = false;
            card.style.borderColor = 'green';
        } else {
            card.style.borderColor = 'red';
            setTimeout(() => card.style.borderColor = '#ccc', 500);
        }
    },
    endGame() { this.active = false; }
};

// --- 3. MEMORY GAME ---
const memoryGame = {
    level: 1, timer: 0, timerId: null, matches: 0, goal: 0,
    isChecking: false, flippedCards: [],
    levelData: [
        { pairs: 4, time: null }, { pairs: 6, time: 90 }, { pairs: 8, time: 120 }
    ],
    
    start() {
        this.resetState();
        const currentLevel = this.levelData[this.level - 1];
        if (!currentLevel) { alert("You've completed all levels!"); resetAndGoHome(); return; }
        
        this.goal = currentLevel.pairs;
        this.timer = currentLevel.time;

        this.updateUI();
        this.createGrid(currentLevel.pairs);
        if (this.timer) this.startTimer();
    },

    createGrid(pairCount) {
        const grid = document.getElementById('memory-game-grid');
        grid.innerHTML = '';
        const columns = pairCount * 2 > 8 ? 4 : 4;
        grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
        
        const activities = [{e:'🙏'}, {e:'📖'}, {e:'🤝'}, {e:'😊'}, {e:'🧹'}, {e:'🎶'}, {e:'🤗'}, {e:'❤️'}];
        let cardPool = activities.slice(0, pairCount);
        cardPool = [...cardPool, ...cardPool];
        cardPool.sort(() => 0.5 - Math.random());

        cardPool.forEach(item => {
            const cardEl = document.createElement('div');
            cardEl.classList.add('memory-card');
            cardEl.dataset.id = item.e;
            cardEl.innerHTML = `<div class="card-face card-back">?</div><div class="card-face card-front">${item.e}</div>`;
            cardEl.onclick = () => this.flipCard(cardEl);
            grid.appendChild(cardEl);
        });
    },

    flipCard(cardEl) {
        if (this.isChecking || cardEl.classList.contains('is-flipped') || this.flippedCards.length >= 2) return;
        cardEl.classList.add('is-flipped');
        this.flippedCards.push(cardEl);
        if (this.flippedCards.length === 2) this.checkForMatch();
    },

    checkForMatch() {
        this.isChecking = true;
        const [card1, card2] = this.flippedCards;
        if (card1.dataset.id === card2.dataset.id) {
            this.matches++;
            this.updateUI();
            setTimeout(() => {
                card1.classList.add('is-matched');
                card2.classList.add('is-matched');
                this.flippedCards = [];
                this.isChecking = false;
                if (this.matches === this.goal) this.levelComplete();
            }, 500);
        } else {
            setTimeout(() => {
                card1.classList.remove('is-flipped');
                card2.classList.remove('is-flipped');
                this.flippedCards = [];
                this.isChecking = false;
            }, 1000);
        }
    },
    
    levelComplete() {
        clearInterval(this.timerId);
        alert(`Level ${this.level} Complete!`);
        if (this.level < this.levelData.length) {
            this.level++;
            this.start();
        } else {
            alert("You beat the Memory Game!");
            resetAndGoHome();
        }
    },
    
    startTimer() {
        const timerEl = document.getElementById('memory-timer');
        this.timerId = setInterval(() => {
            this.timer--;
            timerEl.textContent = this.timer;
            if (this.timer <= 0) {
                clearInterval(this.timerId);
                alert("Time's up! Try again.");
                this.start();
            }
        }, 1000);
    },
    
    updateUI() {
        document.getElementById('memory-level').textContent = this.level;
        document.getElementById('memory-matches').textContent = `${this.matches} / ${this.goal}`;
        document.getElementById('memory-timer').textContent = this.timer || '--';
    },

    resetState() {
        this.matches = 0;
        this.isChecking = false;
        this.flippedCards = [];
        if (this.timerId) clearInterval(this.timerId);
        this.timerId = null;
    }
};


// --- INITIALIZATION & EVENT LISTENERS ---
window.onload = () => {
    document.getElementById('start-sorting-btn').onclick = () => {
        switchScreen('sorting-game-screen');
        sortingGame.start();
    };
    document.getElementById('start-memory-btn').onclick = () => {
        switchScreen('memory-game-screen');
        memoryGame.level = 1;
        memoryGame.start();
    };
    document.getElementById('start-minigame-btn').onclick = () => {
        switchScreen('minigame-screen');
        platformFighter.init();
    };
    document.getElementById('character-selector').onchange = (e) => {
        game.character = e.target.value;
    };
};
</script>

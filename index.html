<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JW Fun & Games - All-in-One</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Comic+Neue:wght@400;700&display=swap">
  <style>
    :root {
      --bg-color: #eaf5ff;
      --panel-bg: #ffffff;
      --primary-text: #3d5a80;
      --accent-green: #2a9d8f;
      --accent-red: #e76f51;
      --accent-orange: #f4a261;
      --font-header: 'Fredoka One', cursive;
      --font-body: 'Comic Neue', sans-serif;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
    }

    /* --- General Setup & Home Button --- */
    body {
      font-family: var(--font-body);
      background-color: var(--bg-color);
      color: var(--primary-text);
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .main-container {
      width: 100%;
      max-width: 900px;
    }
    .panel {
      background-color: var(--panel-bg);
      border-radius: 20px;
      padding: 20px 30px;
      box-shadow: var(--shadow);
      margin-bottom: 20px;
    }
    h2, h3 {
      font-family: var(--font-header);
      color: var(--primary-text);
      margin-top: 0;
    }
    .screen { display: none; }
    .screen.active { display: block; }
    
    #home-reset-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      background-color: var(--accent-orange);
      color: white;
      font-size: 1.8rem;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      transition: transform 0.2s ease, background-color 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #home-reset-btn:hover {
      transform: scale(1.1);
      background-color: #e76f51;
    }
    .nav-button {
      margin: 10px;
      padding: 15px 30px;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      font-family: var(--font-header);
      font-size: 1.2rem;
      color: white;
      box-shadow: var(--shadow);
    }

    /* --- Main Menu --- */
    #main-menu-screen .panel { text-align: center; }
    #character-selector { display: flex; justify-content: center; gap: 15px; margin-top: 15px; }
    #character-selector input[type="radio"] { display: none; }
    #character-selector label { padding: 8px 15px; border-radius: 50px; cursor: pointer; font-weight: bold; background-color: #f0f0f0; transition: all 0.2s ease-in-out; }
    #character-selector input[type="radio"]:checked + label { background-color: var(--accent-orange); color: white; transform: scale(1.1); }
    #game-selection-buttons { margin-top: 20px; }
    
    /* --- Sorting Game --- */
    .drop-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .dropzone { border: 3px dashed #ccc; min-height: 200px; padding: 15px; border-radius: 15px; transition: all 0.3s; }
    #closer { background-color: #e8f5e9; }
    #distraction { background-color: #ffebee; }
    .dropzone.over { transform: scale(1.02); border-color: var(--accent-orange); }
    #cards-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; min-height: 150px; padding: 20px 0; }
    .card { background-color: var(--panel-bg); border: 3px solid #ccc; padding: 15px; border-radius: 12px; cursor: grab; display: flex; align-items: center; gap: 10px; box-shadow: var(--shadow); transition: transform 0.2s; }
    .card:hover { transform: translateY(-5px); }
    .card .emoji { font-size: 2rem; }

    /* --- Memory Game --- */
    .memory-header { display: flex; justify-content: space-around; font-family: var(--font-header); font-size: 1.2rem; }
    #memory-game-grid { display: grid; gap: 10px; margin: 20px auto; max-width: 600px; }
    .memory-card { width: 100%; aspect-ratio: 1 / 1; position: relative; transform-style: preserve-3d; transition: transform 0.6s; cursor: pointer; }
    .memory-card.is-flipped { transform: rotateY(180deg); }
    .memory-card.is-matched { opacity: 0.5; pointer-events: none; }
    .card-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; align-items: center; justify-content: center; flex-direction: column; border-radius: 10px; }
    .card-front { background: white; border: 3px solid #ccc; transform: rotateY(180deg); font-size: 3rem; }
    .card-back { background: linear-gradient(135deg, #6a0dad, #9c27b0); font-size: 3rem; color: white; }

    /* --- Minigame --- */
    #minigame-screen { text-align: center; }
    .minigame-header { display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; }
    .minigame-stat { font-family: var(--font-header); font-size: 1.2rem; }
    .minigame-stat .hearts { font-size: 1.8rem; letter-spacing: 2px; }
    #minigame-canvas-container { position: relative; background-color: #7ec0ee; border-radius: 15px; overflow: hidden; box-shadow: var(--shadow); }
    canvas#minigame-canvas { width: 100%; display: block; }
    #minigame-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: none; flex-direction: column; align-items: center; justify-content: center; color: white; text-shadow: 2px 2px 4px #000; font-family: var(--font-header); background: rgba(0,0,0,0.4); }
    #minigame-overlay h2 { font-size: 3rem; margin-bottom: 20px; }
    #minigame-start-btn, #minigame-next-level-btn { padding: 15px 30px; font-size: 1.5rem; background-color: var(--accent-orange); color: white; border: none; border-radius: 15px; cursor: pointer; margin-top: 10px; }
  </style>
</head>
<body>

<button id="home-reset-btn" title="Reset Game and Go Home">üè†</button>

<div class="main-container">

  <div id="main-menu-screen" class="screen active">
    <div class="panel">
      <h2>JW Fun & Games!</h2>
      <p>Choose your character and pick a game to play.</p>
      <div id="character-selector">
        <input type="radio" id="char-boy" name="character" value="boy" checked><label for="char-boy">Boy üë¶</label>
        <input type="radio" id="char-girl" name="character" value="girl"><label for="char-girl">Girl üëß</label>
      </div>
      <div id="game-selection-buttons">
        <button id="start-sorting-btn" class="nav-button" style="background-color: var(--accent-green);">Spot the Distraction</button>
        <button id="start-memory-btn" class="nav-button" style="background-color: #9c27b0;">Memory Match</button>
        <button id="start-minigame-btn" class="nav-button" style="background-color: #2196F3;">Platform Adventure</button>
      </div>
    </div>
  </div>

  <div id="sorting-game-screen" class="screen">
    <div class="panel">
        <h2>Spot the Distraction</h2>
        <div class="drop-container">
            <div id="closer" class="dropzone"><h3>üëç Keeps Me Close to Jehovah</h3></div>
            <div id="distraction" class="dropzone"><h3>ü§î Could Be a Distraction</h3></div>
        </div>
        <h3 style="text-align: center;">Drag the Activities</h3>
        <div id="cards-container"></div>
    </div>
  </div>

  <div id="memory-game-screen" class="screen">
      <div class="panel">
          <h2>Memory Match Challenge</h2>
          <div class="memory-header">
              <span>Level: <span id="memory-level">1</span></span>
              <span>Matches: <span id="memory-matches">0 / 0</span></span>
              <span>Time: <span id="memory-timer">--</span></span>
          </div>
          <div id="memory-game-grid"></div>
      </div>
  </div>

  <div id="minigame-screen" class="screen">
    <div class="panel">
      <h2>Platform Adventure!</h2>
      <div class="minigame-header">
        <div class="minigame-stat">Level: <span id="minigame-level">1</span></div>
        <div class="minigame-stat">Tokens: <span id="minigame-tokens">0 / 5</span></div>
        <div class="minigame-stat"><span class="hearts" id="minigame-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
      </div>
      <div id="minigame-canvas-container">
          <canvas id="minigame-canvas" width="800" height="450"></canvas>
          <div id="minigame-overlay">
              <h2 id="minigame-message"></h2>
              <button id="minigame-start-btn">Start Adventure üöÄ</button>
              <button id="minigame-next-level-btn" style="display:none;">Next Level! ‚ú®</button>
          </div>
      </div>
    </div>
  </div>
</div>

<script>
// --- GLOBAL & MENU LOGIC ---
const initialGameState = { character: 'boy' };
let game = { ...initialGameState };

function switchScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
    
    if (platformFighter.active) platformFighter.endGame(false, true);
    if (memoryGame.timerId) clearInterval(memoryGame.timerId);
    if (sortingGame.active) sortingGame.endGame();
}

function resetAndGoHome() {
    game = { ...initialGameState };
    document.getElementById(`char-${game.character}`).checked = true;
    switchScreen('main-menu-screen');
}

document.getElementById('home-reset-btn').onclick = resetAndGoHome;


// --- 1. PLATFORM ADVENTURE MINIGAME ---

// Simple sound generator using Web Audio API (no audio files needed)
const sound = {
    audioCtx: null,
    init() {
        if (this.audioCtx) return;
        try { this.audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        catch (e) { console.error("Web Audio API is not supported in this browser"); }
    },
    play(freq, duration, type = 'sine') {
        if (!this.audioCtx) return;
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.00001, this.audioCtx.currentTime + duration);
        osc.start(this.audioCtx.currentTime);
        osc.stop(this.audioCtx.currentTime + duration);
    },
    jump: function() { this.play(440, 0.1, 'square'); },
    collect: function() { this.play(880, 0.15, 'triangle'); },
    hurt: function() { this.play(220, 0.3, 'sawtooth'); },
    powerup: function() { this.play(660, 0.2, 'sine'); },
    levelComplete: function() { this.play(1000, 0.5, 'sine'); }
};

// Data for all game levels
const levelDesigns = [
    {}, // Level 0 placeholder
    { // Level 1
        goal: { x: 2200, y: 300, w: 50, h: 100 },
        platforms: [
            { x: -100, y: 400, w: 800, h: 50 },
            { x: 850, y: 320, w: 150, h: 30 },
            { x: 1100, y: 250, w: 150, h: 30 },
            { x: 850, y: 180, w: 100, h: 30 },
            { x: 1400, y: 400, w: 900, h: 50 },
        ],
        movingPlatforms: [],
        enemies: [{ x: 500, y: 360, w: 40, h: 40, startX: 500, endX: 650, speed: 1.5 }],
        tokens: [ {x: 875, y: 280}, {x: 1125, y: 210}, {x: 875, y: 140}, {x: 1600, y: 350}, {x: 1800, y: 350} ],
        checkpoints: [],
        powerups: [],
        tokenGoal: 5
    },
    { // Level 2
        goal: { x: 3000, y: 300, w: 50, h: 100 },
        platforms: [
            { x: -100, y: 400, w: 500, h: 50 },
            { x: 800, y: 300, w: 150, h: 30 },
            { x: 1400, y: 180, w: 100, h: 30 },
            { x: 2000, y: 400, w: 1100, h: 50 }
        ],
        movingPlatforms: [
            { x: 500, y: 400, w: 150, h: 30, startX: 500, endX: 750, speed: 2 },
            { x: 1600, y: 400, w: 120, h: 30, startX: 1600, endX: 1900, speed: 2.5 }
        ],
        enemies: [
            { x: 2100, y: 360, w: 40, h: 40, startX: 2100, endX: 2300, speed: 2 },
            { x: 2500, y: 360, w: 40, h: 40, startX: 2500, endX: 2700, speed: 2.5 }
        ],
        tokens: [ {x: 825, y: 260}, {x: 600, y: 300}, {x: 1425, y: 140}, {x: 1750, y: 300}, {x: 2600, y: 300} ],
        checkpoints: [{ x: 1800, y: 340, w: 40, h: 60, activated: false }],
        powerups: [{ x: 2800, y: 360, w: 30, h: 30, type: 'doubleJump' }],
        tokenGoal: 5
    }
];

const platformFighter = {
    canvas: document.getElementById('minigame-canvas'),
    ctx: null, active: false, gameInterval: null, frame: 0,
    level: 1, lives: 3, tokens: 0,
    
    player: {}, // Player object will be reset on start
    platforms: [], enemies: [], tokens: [], movingPlatforms: [], checkpoints: [], powerups: [], goal: {},
    particles: [], gravity: 0.8, camera: { x: 0 },

    characterArt: {
        boy: { skin: '#f2a66e', skin_s: '#d88c57', hair: '#3a2d27', shirt: '#4a90e2', shirt_s: '#3b73b5', pants: '#333', pants_s: '#222' },
        girl: { skin: '#ffbe87', skin_s: '#e5a36f', hair: '#8b572a', shirt: '#e91e63', shirt_s: '#c2185b', pants: '#555', pants_s: '#444' }
    },
    
    init() {
        this.ctx = this.canvas.getContext('2d');
        sound.init();
        document.getElementById('minigame-start-btn').onclick = () => this.start();
        document.getElementById('minigame-next-level-btn').onclick = () => { this.level++; this.start(); };
        this.showOverlay("Platform Adventure");
    },

    start() {
        this.hideOverlay();
        this.active = true;
        this.frame = 0;
        this.lives = 3;
        this.tokens = 0;
        this.camera.x = 0;
        this.particles = [];
        this.resetPlayer();
        this.loadLevel();
        if (this.gameInterval) clearInterval(this.gameInterval);
        this.gameInterval = setInterval(() => this.loop(), 1000 / 60);
        this.addKeyListeners();
    },
    
    resetPlayer() {
        this.player = {
            x: 100, y: 300, w: 40, h: 60, vx: 0, vy: 0,
            speed: 5, jumpPower: 16,
            grounded: false, jumps: 1, maxJumps: 1,
            isInvincible: false, invincibleTimer: 0,
            powerupTimer: 0,
            animState: 'idle', animFrame: 0, facing: 'right', squash: 0,
            respawnPos: { x: 100, y: 300 }
        };
    },
    
    loadLevel() {
        const levelData = levelDesigns[this.level];
        if (!levelData) {
            this.endGame(true); // No more levels, game won
            this.showOverlay("You Win! üéâ");
            return;
        }
        this.platforms = JSON.parse(JSON.stringify(levelData.platforms));
        this.movingPlatforms = JSON.parse(JSON.stringify(levelData.movingPlatforms));
        this.enemies = JSON.parse(JSON.stringify(levelData.enemies));
        this.tokens = JSON.parse(JSON.stringify(levelData.tokens)).map(t => ({...t, w: 20, h: 20, collected: false}));
        this.checkpoints = JSON.parse(JSON.stringify(levelData.checkpoints || []));
        this.powerups = JSON.parse(JSON.stringify(levelData.powerups || []));
        this.goal = { ...levelData.goal };
        this.tokenGoal = levelData.tokenGoal;
    },

    keys: {},
    addKeyListeners() {
        this.keys = {};
        window.onkeydown = e => {
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                if (this.player.jumps > 0) {
                    this.player.vy = -this.player.jumpPower;
                    this.player.jumps--;
                    sound.jump();
                    this.spawnParticles(this.player.x + this.player.w / 2, this.player.y + this.player.h, 10, '#f4a261');
                }
            }
            this.keys[e.code] = true;
        };
        window.onkeyup = e => this.keys[e.code] = false;
    },
    
    loop() {
        this.updatePlayer();
        this.updateEnemies();
        this.updateMovingPlatforms();
        this.updateParticles();
        this.updateCamera();
        this.draw();
        this.updateUI();
        this.frame++;
    },
    
    updatePlayer() {
        const p = this.player;
        if (p.squash > 0) p.squash -= 0.1;
        if (p.invincibleTimer > 0) p.invincibleTimer--;
        else p.isInvincible = false;
        
        if (p.powerupTimer > 0) p.powerupTimer--;
        else p.maxJumps = 1; // Reset powerup

        // Horizontal Movement
        if (this.keys.KeyA || this.keys.ArrowLeft) { p.vx = -p.speed; p.facing = 'left'; }
        else if (this.keys.KeyD || this.keys.ArrowRight) { p.vx = p.speed; p.facing = 'right'; }
        else { p.vx = 0; }
        
        p.x += p.vx;
        this.handleCollisions('x');

        // Vertical Movement
        p.vy += this.gravity;
        p.y += p.vy;
        p.grounded = false;
        this.handleCollisions('y');

        // Other Collisions
        this.handleObjectCollisions();
        
        // Fall off map
        if (p.y > this.canvas.height + 100) this.takeDamage();

        // Animation
        p.animFrame++;
        if (!p.grounded) p.animState = p.vy < 0 ? 'jump' : 'fall';
        else if (p.vx !== 0) p.animState = 'run';
        else p.animState = 'idle';
    },

    handleCollisions(axis) {
        const p = this.player;
        const allPlatforms = [...this.platforms, ...this.movingPlatforms];

        allPlatforms.forEach(plat => {
            if (this.checkCollision(p, plat)) {
                if (axis === 'y') {
                    if (p.vy > 0) { // Moving down
                        if (p.y + p.h - p.vy <= plat.y + 1) { // Was above platform last frame
                            p.y = plat.y - p.h;
                            p.vy = 0;
                            if (!p.grounded) {
                                p.squash = 1;
                                this.spawnParticles(p.x + p.w / 2, p.y + p.h, 15, '#ffffff');
                            }
                            p.grounded = true;
                            p.jumps = p.maxJumps;
                        }
                    } else if (p.vy < 0) { // Moving up
                         if (p.y - p.vy >= plat.y + plat.h) {
                            p.y = plat.y + plat.h;
                            p.vy = 0;
                         }
                    }
                }
                if (axis === 'x') {
                    if (p.vx > 0) { // Moving right
                        if (p.x + p.w - p.vx <= plat.x) {
                           p.x = plat.x - p.w;
                        }
                    } else if (p.vx < 0) { // Moving left
                        if (p.x - p.vx >= plat.x + plat.w) {
                           p.x = plat.x + plat.w;
                        }
                    }
                }
            }
        });
        
        // Add moving platform velocity to player
        if (p.grounded) {
            this.movingPlatforms.forEach(plat => {
                let tempPlayer = { ...p, y: p.y + 1, h: 1 }; // Check slightly below player
                if (this.checkCollision(tempPlayer, plat)) {
                    p.x += plat.vx || 0;
                }
            });
        }
    },
    
    handleObjectCollisions() {
        // Enemies
        this.enemies.forEach(e => {
            if (!this.player.isInvincible && this.checkCollision(this.player, e)) this.takeDamage();
        });
        // Tokens
        this.tokens.forEach(t => {
            if (!t.collected && this.checkCollision(this.player, t)) {
                t.collected = true;
                this.tokens++;
                sound.collect();
                this.spawnParticles(t.x + t.w/2, t.y + t.h/2, 20, 'gold');
            }
        });
        // Checkpoints
        this.checkpoints.forEach(c => {
            if (!c.activated && this.checkCollision(this.player, c)) {
                c.activated = true;
                this.player.respawnPos = { x: c.x, y: c.y - this.player.h };
                sound.powerup();
            }
        });
        // Powerups
        this.powerups.forEach((p, i) => {
            if(this.checkCollision(this.player, p)) {
                if(p.type === 'doubleJump') {
                    this.player.maxJumps = 2;
                    this.player.jumps = 2; // give them the jumps immediately
                    this.player.powerupTimer = 600; // 10 seconds
                }
                this.powerups.splice(i, 1);
                sound.powerup();
            }
        });
        // Goal
        if (this.tokens >= this.tokenGoal && this.checkCollision(this.player, this.goal)) {
            sound.levelComplete();
            if (this.level < levelDesigns.length - 1) {
                this.showOverlay(`Level ${this.level} Complete!`, true);
                this.endGame(true, false);
            } else {
                this.showOverlay("You Win! üéâ");
                this.endGame(true, false);
            }
        }
    },
    
    takeDamage() {
        if (this.player.isInvincible) return;
        this.lives--;
        sound.hurt();
        if (this.lives <= 0) {
            this.endGame(false, false);
            this.showOverlay("Game Over");
        } else {
            this.player.isInvincible = true;
            this.player.invincibleTimer = 120; // 2 seconds
            this.player.x = this.player.respawnPos.x;
            this.player.y = this.player.respawnPos.y;
            this.player.vy = 0;
        }
    },
    
    updateEnemies() {
        this.enemies.forEach(e => {
            e.x += e.speed;
            if (e.x < e.startX || e.x + e.w > e.endX) {
                e.speed *= -1;
            }
        });
    },

    updateMovingPlatforms() {
        this.movingPlatforms.forEach(p => {
            p.vx = p.speed;
            p.x += p.vx;
            if (p.x < p.startX || p.x + p.w > p.endX) {
                p.speed *= -1;
            }
        });
    },

    updateCamera() {
        const targetX = this.player.x - this.canvas.width / 3;
        this.camera.x += (targetX - this.camera.x) * 0.1;
        if(this.camera.x < 0) this.camera.x = 0;
    },
    
    spawnParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4 - 2,
                life: Math.random() * 40 + 20,
                color
            });
        }
    },
    updateParticles() {
        this.particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life--;
            if (p.life <= 0) this.particles.splice(i, 1);
        });
    },
    checkCollision(r1, r2) { return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.h + r1.y > r2.y; },

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.save();
        this.ctx.translate(-this.camera.x, 0);
        this.drawBackground();
        [...this.platforms, ...this.movingPlatforms].forEach(p => this.drawPlatform(p));
        this.drawGoal();
        this.drawCheckpoints();
        this.drawPowerups();
        this.tokens.forEach(t => { if (!t.collected) this.drawToken(t); });
        this.enemies.forEach(e => this.drawEnemy(e));
        this.particles.forEach(p => {
            this.ctx.fillStyle = p.color;
            this.ctx.globalAlpha = p.life / 60;
            this.ctx.fillRect(p.x, p.y, 3, 3);
            this.ctx.globalAlpha = 1;
        });
        this.drawCharacter();
        this.ctx.restore();
    },
    
    drawBackground() {
        const grad = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        grad.addColorStop(0, '#87CEEB'); grad.addColorStop(1, '#bde0fe');
        this.ctx.fillStyle = grad;
        this.ctx.fillRect(this.camera.x, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        this.ctx.beginPath();
        this.ctx.ellipse(200 - this.camera.x * 0.2, 100, 150, 40, 0, 0, Math.PI * 2);
        this.ctx.ellipse(600 - this.camera.x * 0.2, 150, 200, 60, 0, 0, Math.PI * 2);
        this.ctx.fill();
    },
    drawPlatform(p) {
        this.ctx.fillStyle = '#6d4c41'; this.ctx.fillRect(p.x, p.y, p.w, p.h);
        this.ctx.fillStyle = '#8bc34a'; this.ctx.fillRect(p.x, p.y, p.w, 10);
    },
    drawGoal() {
        this.ctx.fillStyle = this.tokens >= this.tokenGoal ? 'gold' : 'rgba(255, 215, 0, 0.3)';
        this.ctx.fillRect(this.goal.x, this.goal.y, this.goal.w, this.goal.h);
        this.ctx.fillStyle = 'black'; this.ctx.font = '20px Fredoka One'; this.ctx.fillText('üèÅ', this.goal.x + 10, this.goal.y + 30);
    },
    drawToken(t) {
        this.ctx.fillStyle = 'gold'; this.ctx.beginPath(); this.ctx.arc(t.x + t.w/2, t.y + t.h/2, t.w/2, 0, Math.PI * 2); this.ctx.fill();
        this.ctx.fillStyle = '#c78d00'; this.ctx.beginPath(); this.ctx.arc(t.x + t.w/2, t.y + t.h/2, t.w/3, 0, Math.PI * 2); this.ctx.fill();
    },
    drawEnemy(e) {
        this.ctx.fillStyle = '#e76f51'; this.ctx.fillRect(e.x, e.y, e.w, e.h);
        this.ctx.fillStyle = 'white'; this.ctx.fillRect(e.x + 8, e.y + 8, 8, 8); this.ctx.fillRect(e.x + 24, e.y + 8, 8, 8);
        this.ctx.fillStyle = 'black'; this.ctx.fillRect(e.x + 10, e.y + 10, 4, 4); this.ctx.fillRect(e.x + 26, e.y + 10, 4, 4);
    },
    drawCheckpoints() {
        this.checkpoints.forEach(c => {
            this.ctx.fillStyle = c.activated ? 'rgba(76, 175, 80, 0.8)' : 'rgba(255, 255, 255, 0.5)';
            this.ctx.fillRect(c.x, c.y, c.w, c.h);
            this.ctx.fillStyle = 'black'; this.ctx.font = '20px Fredoka One'; this.ctx.fillText('üè≥Ô∏è', c.x + 5, c.y + 25);
        });
    },
    drawPowerups() {
        this.powerups.forEach(p => {
            this.ctx.fillStyle = '#9c27b0'; this.ctx.fillRect(p.x, p.y, p.w, p.h);
            this.ctx.fillStyle = 'white'; this.ctx.font = '20px Fredoka One'; this.ctx.fillText('J+', p.x + 3, p.y + 22);
        });
    },
    drawCharacter() {
        if (this.player.isInvincible && this.frame % 10 < 5) return;
        const p = this.player;
        const art = this.characterArt[game.character];
        const frame = p.animFrame;
        const ctx = this.ctx;

        let squashFactor = 1 - Math.sin(p.squash * Math.PI) * 0.2;
        let stretchFactor = 1 + Math.sin(p.squash * Math.PI) * 0.2;

        ctx.save();
        ctx.translate(p.x + p.w / 2, p.y + p.h);
        if (p.facing === 'left') ctx.scale(-1, 1);
        ctx.translate(0, -p.h); 
        ctx.scale(stretchFactor, squashFactor);
        ctx.translate(0, p.h);

        let bob = Math.sin(frame * 0.2) * 2;
        let armSwing = Math.sin(frame * 0.4) * 35;
        let legSwing = Math.sin(frame * 0.4) * 45;

        if (p.animState === 'idle') { armSwing /= 4; legSwing = 0; }
        if (p.animState === 'jump' || p.animState === 'fall') {
            bob = 0; armSwing = -30; legSwing = 30;
            if (p.animState === 'fall') { armSwing = 30; legSwing = -30; }
        }
        
        const drawLimb = (x, y, angle, length, width, color1, color2) => {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle * Math.PI / 180);
            ctx.fillStyle = color2;
            ctx.fillRect(-width/2 -1, 0, width+2, -length-1);
            ctx.fillStyle = color1;
            ctx.fillRect(-width/2, 0, width, -length);
            ctx.beginPath(); ctx.arc(0, -length, width/2, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        };
        
        const torsoY = -p.h / 2 + bob, headY = -p.h + 10 + bob * 1.5;
        
        drawLimb(5, torsoY, legSwing, p.h * 0.45, 12, art.pants_s, '#000'); 
        drawLimb(-5, torsoY, armSwing, p.h * 0.4, 10, art.skin_s, '#000');
        
        ctx.fillStyle = art.shirt_s; ctx.fillRect(-16, torsoY-21, 32, 42); 
        ctx.fillStyle = art.shirt; ctx.fillRect(-15, torsoY-20, 30, 40);
        
        drawLimb(-5, torsoY, -legSwing, p.h * 0.45, 12, art.pants, '#000');
        drawLimb(5, torsoY, -armSwing, p.h * 0.4, 10, art.skin, '#000');

        ctx.fillStyle = art.skin_s; ctx.beginPath(); ctx.arc(0, headY+1, 16, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = art.skin; ctx.beginPath(); ctx.arc(0, headY, 15, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = art.hair; ctx.beginPath(); ctx.arc(0, headY-5, 15, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.ellipse(8, headY, 5, 7, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(10, headY, 3, 0, Math.PI * 2); ctx.fill();

        ctx.restore();
    },

    showOverlay(message, showNextLevelBtn = false) {
        const overlay = document.getElementById('minigame-overlay');
        document.getElementById('minigame-message').textContent = message;
        document.getElementById('minigame-start-btn').style.display = showNextLevelBtn ? 'none' : 'inline-block';
        document.getElementById('minigame-next-level-btn').style.display = showNextLevelBtn ? 'inline-block' : 'none';
        overlay.style.display = 'flex';
    },
    hideOverlay() { 
        document.getElementById('minigame-overlay').style.display = 'none'; 
    },
    endGame(isComplete = false, isReset = false) {
        this.active = false;
        clearInterval(this.gameInterval);
        window.onkeydown = null; window.onkeyup = null;
        if (isReset) return;
        if (!isComplete) this.showOverlay("Game Over");
    },
    updateUI() {
        const levelData = levelDesigns[this.level];
        if(!levelData) return;
        document.getElementById('minigame-level').textContent = this.level;
        document.getElementById('minigame-tokens').textContent = `${this.tokens} / ${levelData.tokenGoal}`;
        document.getElementById('minigame-lives').textContent = '‚ù§Ô∏è'.repeat(this.lives) + 'üñ§'.repeat(Math.max(0, 3 - this.lives));
    }
};

// --- 2. SORTING GAME ---
const sortingGame = {
    active: false,
    allActivities: {
      boy: { // Formerly 'cello'
        closer: [ { emoji: 'üôè', text: "Praying" }, { emoji: 'üßπ', text: "Helping clean" }, { emoji: 'üìñ', text: "Reading Bible story" }, { emoji: 'ü§ó', text: "Sharing toys" } ],
        distraction: [ { emoji: 'üéÆ', text: "Video games all evening" }, { emoji: 'üì∫', text: "Watching TV late" }, { emoji: 'üò†', text: "Arguing" }, { emoji: 'üò´', text: "Complaining" } ]
      },
      girl: { // Formerly 'fina'
        closer: [ { emoji: 'üôè', text: "Personal prayer" }, { emoji: 'ü§ù', text: "Helping a friend" }, { emoji: 'üìñ', text: "Personal Bible reading" }, { emoji: 'üìù', text: "Meeting prep" } ],
        distraction: [ { emoji: 'üì±', text: "Hours on social media" }, { emoji: ' gossip', text: "Gossiping" }, { emoji: 'üëª', text: "Scary movies" }, { emoji: 'ü§î', text: "Worrying about popularity" } ]
      }
    },
    
    start() {
        this.active = true;
        this.loadCards();
    },

    loadCards() {
        const cardContainer = document.getElementById('cards-container');
        cardContainer.innerHTML = '';
        document.getElementById('closer').innerHTML = '<h3>üëç Keeps Me Close to Jehovah</h3>';
        document.getElementById('distraction').innerHTML = '<h3>ü§î Could Be a Distraction</h3>';

        const mode = game.character === 'boy' ? 'boy' : 'girl';
        const activities = [...this.allActivities[mode].closer, ...this.allActivities[mode].distraction];
        activities.sort(() => 0.5 - Math.random()); // Shuffle

        activities.forEach((activity, idx) => {
            const card = document.createElement("div");
            card.className = "card";
            card.id = `card${idx}`;
            card.draggable = true;
            card.innerHTML = `<span class="emoji">${activity.emoji}</span><span>${activity.text}</span>`;
            
            const isCloser = this.allActivities[mode].closer.some(c => c.text === activity.text);
            card.dataset.correctZone = isCloser ? 'closer' : 'distraction';
            
            card.ondragstart = (e) => e.dataTransfer.setData("text", e.target.id);
            cardContainer.appendChild(card);
        });
        
        document.querySelectorAll('.dropzone').forEach(zone => {
            zone.ondragover = (e) => e.preventDefault();
            zone.ondrop = this.onDrop;
        });
    },

    onDrop(e) {
        e.preventDefault();
        const cardId = e.dataTransfer.getData("text");
        const card = document.getElementById(cardId);
        let dropzone = e.target;
        while (!dropzone.classList.contains('dropzone')) dropzone = dropzone.parentElement;
        
        if (card.dataset.correctZone === dropzone.id) {
            dropzone.appendChild(card);
            card.draggable = false;
            card.style.borderColor = 'green';
        } else {
            card.style.borderColor = 'red';
            setTimeout(() => card.style.borderColor = '#ccc', 500);
        }
    },
    endGame() { this.active = false; }
};

// --- 3. MEMORY GAME ---
const memoryGame = {
    level: 1, timer: 0, timerId: null, matches: 0, goal: 0,
    isChecking: false, flippedCards: [],
    levelData: [
        { pairs: 4, time: null }, { pairs: 6, time: 90 }, { pairs: 8, time: 120 }
    ],
    
    start() {
        this.resetState();
        const currentLevel = this.levelData[this.level - 1];
        if (!currentLevel) { alert("You've completed all levels!"); resetAndGoHome(); return; }
        
        this.goal = currentLevel.pairs;
        this.timer = currentLevel.time;

        this.updateUI();
        this.createGrid(currentLevel.pairs);
        if (this.timer) this.startTimer();
    },

    createGrid(pairCount) {
        const grid = document.getElementById('memory-game-grid');
        grid.innerHTML = '';
        const columns = pairCount * 2 > 8 ? 4 : 4;
        grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
        
        const activities = [{e:'üôè'}, {e:'üìñ'}, {e:'ü§ù'}, {e:'üòä'}, {e:'üßπ'}, {e:'üé∂'}, {e:'ü§ó'}, {e:'‚ù§Ô∏è'}];
        let cardPool = activities.slice(0, pairCount);
        cardPool = [...cardPool, ...cardPool];
        cardPool.sort(() => 0.5 - Math.random());

        cardPool.forEach(item => {
            const cardEl = document.createElement('div');
            cardEl.classList.add('memory-card');
            cardEl.dataset.id = item.e;
            cardEl.innerHTML = `<div class="card-face card-back">?</div><div class="card-face card-front">${item.e}</div>`;
            cardEl.onclick = () => this.flipCard(cardEl);
            grid.appendChild(cardEl);
        });
    },

    flipCard(cardEl) {
        if (this.isChecking || cardEl.classList.contains('is-flipped') || this.flippedCards.length >= 2) return;
        cardEl.classList.add('is-flipped');
        this.flippedCards.push(cardEl);
        if (this.flippedCards.length === 2) this.checkForMatch();
    },

    checkForMatch() {
        this.isChecking = true;
        const [card1, card2] = this.flippedCards;
        if (card1.dataset.id === card2.dataset.id) {
            this.matches++;
            this.updateUI();
            setTimeout(() => {
                card1.classList.add('is-matched');
                card2.classList.add('is-matched');
                this.flippedCards = [];
                this.isChecking = false;
                if (this.matches === this.goal) this.levelComplete();
            }, 500);
        } else {
            setTimeout(() => {
                card1.classList.remove('is-flipped');
                card2.classList.remove('is-flipped');
                this.flippedCards = [];
                this.isChecking = false;
            }, 1000);
        }
    },
    
    levelComplete() {
        clearInterval(this.timerId);
        alert(`Level ${this.level} Complete!`);
        if (this.level < this.levelData.length) {
            this.level++;
            this.start();
        } else {
            alert("You beat the Memory Game!");
            resetAndGoHome();
        }
    },
    
    startTimer() {
        const timerEl = document.getElementById('memory-timer');
        this.timerId = setInterval(() => {
            this.timer--;
            timerEl.textContent = this.timer;
            if (this.timer <= 0) {
                clearInterval(this.timerId);
                alert("Time's up! Try again.");
                this.start();
            }
        }, 1000);
    },
    
    updateUI() {
        document.getElementById('memory-level').textContent = this.level;
        document.getElementById('memory-matches').textContent = `${this.matches} / ${this.goal}`;
        document.getElementById('memory-timer').textContent = this.timer || '--';
    },

    resetState() {
        this.matches = 0;
        this.isChecking = false;
        this.flippedCards = [];
        if (this.timerId) clearInterval(this.timerId);
        this.timerId = null;
    }
};


// --- INITIALIZATION & EVENT LISTENERS ---
window.onload = () => {
    document.getElementById('start-sorting-btn').onclick = () => {
        switchScreen('sorting-game-screen');
        sortingGame.start();
    };
    document.getElementById('start-memory-btn').onclick = () => {
        switchScreen('memory-game-screen');
        memoryGame.level = 1;
        memoryGame.start();
    };
    document.getElementById('start-minigame-btn').onclick = () => {
        switchScreen('minigame-screen');
        platformFighter.init();
    };
    document.getElementById('character-selector').onchange = (e) => {
        game.character = e.target.value;
    };
};
</script>
</body>
</html>

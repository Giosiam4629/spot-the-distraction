<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>JW Fun & Games - Plagues Adventure</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Comic+Neue:wght@400;700&display=swap">
  <style>
    :root {
      --bg-color: #eaf5ff;
      --panel-bg: #ffffff;
      --primary-text: #3d5a80;
      --accent-green: #2a9d8f;
      --accent-red: #e76f51;
      --accent-orange: #f4a261;
      --font-header: 'Fredoka One', cursive;
      --font-body: 'Comic Neue', sans-serif;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
    }

    /* --- General Setup & Home Button --- */
    html, body {
        overscroll-behavior-y: contain; /* Prevents pull-to-refresh on mobile */
    }
    body {
      font-family: var(--font-body);
      background-color: var(--bg-color);
      color: var(--primary-text);
      margin: 0;
      padding: 15px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .main-container {
      width: 100%;
      max-width: 900px;
    }
    .panel {
      background-color: var(--panel-bg);
      border-radius: 20px;
      padding: 20px 30px;
      box-shadow: var(--shadow);
      margin-bottom: 20px;
    }
    h2, h3 {
      font-family: var(--font-header);
      color: var(--primary-text);
      margin-top: 0;
      text-align: center;
    }
    .screen { display: none; }
    .screen.active { display: block; }
    
    #home-reset-btn {
      position: fixed;
      top: 15px;
      right: 15px;
      z-index: 1000;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      background-color: var(--accent-orange);
      color: white;
      font-size: 1.8rem;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      transition: transform 0.2s ease, background-color 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #home-reset-btn:hover {
      transform: scale(1.1);
      background-color: #e76f51;
    }
    .nav-button {
      margin: 10px 0;
      padding: 15px 25px;
      width: 100%;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      font-family: var(--font-header);
      font-size: 1.2rem;
      color: white;
      box-shadow: var(--shadow);
      display: block;
    }
    .instructions {
        text-align: center;
        margin-bottom: 15px;
        font-style: italic;
    }

    /* --- Main Menu --- */
    #main-menu-screen .panel { text-align: center; }
    #character-selector { display: flex; justify-content: center; gap: 15px; margin-top: 15px; }
    #character-selector input[type="radio"] { display: none; }
    #character-selector label { padding: 8px 15px; border-radius: 50px; cursor: pointer; font-weight: bold; background-color: #f0f0f0; transition: all 0.2s ease-in-out; }
    #character-selector input[type="radio"]:checked + label { background-color: var(--accent-orange); color: white; transform: scale(1.1); }
    #game-selection-buttons { margin-top: 20px; }
    
    /* --- Sorting Game --- */
    .drop-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
    .dropzone { border: 3px dashed #ccc; min-height: 200px; padding: 10px; border-radius: 15px; transition: all 0.3s; }
    #makes-happy { background-color: #e8f5e9; }
    #distraction { background-color: #ffebee; }
    .dropzone.over { transform: scale(1.02); border-color: var(--accent-orange); }
    #cards-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; min-height: 100px; padding: 20px 0; }
    .card { background-color: var(--panel-bg); border: 3px solid #ccc; padding: 15px; border-radius: 12px; cursor: grab; display: flex; flex-direction: column; align-items: center; text-align: center; gap: 5px; box-shadow: var(--shadow); transition: transform 0.2s; width: 120px; }
    .card:hover { transform: translateY(-5px); }
    .card .emoji { font-size: 2rem; }

    /* --- Memory Game --- */
    .memory-header { display: flex; justify-content: space-around; font-family: var(--font-header); font-size: 1.2rem; margin-bottom: 15px; }
    #memory-game-grid { display: grid; gap: 10px; margin: 10px auto; max-width: 600px; }
    .memory-card { width: 100%; aspect-ratio: 1 / 1; position: relative; transform-style: preserve-3d; transition: transform 0.6s; cursor: pointer; }
    .memory-card.is-flipped { transform: rotateY(180deg); }
    .memory-card.is-matched { opacity: 0.5; pointer-events: none; }
    .card-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; align-items: center; justify-content: center; flex-direction: column; border-radius: 10px; }
    .card-front { background: white; border: 3px solid #ccc; transform: rotateY(180deg); font-size: 2.5rem; }
    .card-back { background: linear-gradient(135deg, #6a0dad, #9c27b0); font-size: 3rem; color: white; }
    @media (max-width: 600px) {
        .card-front { font-size: 1.8rem; }
        .card-back { font-size: 2.2rem; }
    }

    /* --- Platformer Game --- */
    #platformer-game-screen { text-align: center; }
    .platformer-header { display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    .platformer-stat { font-family: var(--font-header); font-size: 1.2rem; }
    .platformer-stat .hearts { font-size: 1.8rem; letter-spacing: 2px; }
    #platformer-canvas-container { 
        position: relative; 
        width: 100%;
        max-width: 800px;
        margin: auto;
        aspect-ratio: 16 / 9;
        background-color: #7ec0ee; 
        border-radius: 15px; 
        overflow: hidden; 
        box-shadow: var(--shadow); 
    }
    canvas#platformer-canvas { width: 100%; height: 100%; display: block; }
    #platformer-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; text-shadow: 2px 2px 4px #000; font-family: var(--font-header); background: rgba(0,0,0,0.5); }
    #platformer-overlay h2 { font-size: clamp(2rem, 10vw, 3.5rem); margin-bottom: 20px; }
    #platformer-start-btn, #platformer-next-level-btn, #platformer-restart-btn { padding: 15px 30px; font-size: clamp(1rem, 5vw, 1.5rem); background-color: var(--accent-orange); color: white; border: none; border-radius: 15px; cursor: pointer; margin-top: 10px; }
  </style>
</head>
<body>

<button id="home-reset-btn" title="Go Home">üè†</button>

<div class="main-container">

  <div id="main-menu-screen" class="screen active">
    <div class="panel">
      <h2>Fun & Games!</h2>
      <p>Choose your character and pick a game to play.</p>
      <div id="character-selector">
        <input type="radio" id="char-boy" name="character" value="boy" checked><label for="char-boy">Boy üë¶</label>
        <input type="radio" id="char-girl" name="character" value="girl"><label for="char-girl">Girl üëß</label>
      </div>
      <div id="game-selection-buttons">
        <button id="start-sorting-btn" class="nav-button" style="background-color: var(--accent-green);">Sorting Challenge</button>
        <button id="start-memory-btn" class="nav-button" style="background-color: #9c27b0;">Memory Match</button>
        <button id="start-platformer-btn" class="nav-button" style="background-color: #2196F3;">Plagues Adventure</button>
      </div>
    </div>
  </div>

  <div id="sorting-game-screen" class="screen">
    <div class="panel">
        <h2>Sorting Challenge</h2>
        <p class="instructions">Drag each activity to the correct box.</p>
        <div class="drop-container">
            <div id="makes-happy" class="dropzone"><h3>üëç Makes Jehovah Happy</h3></div>
            <div id="distraction" class="dropzone"><h3>ü§î Could Be a Distraction</h3></div>
        </div>
        <div id="cards-container"></div>
    </div>
  </div>

  <div id="memory-game-screen" class="screen">
      <div class="panel">
          <h2>Memory Match</h2>
          <div class="memory-header">
              <span>Level: <span id="memory-level">1</span></span>
              <span>Matches: <span id="memory-matches">0 / 0</span></span>
          </div>
          <div id="memory-game-grid"></div>
      </div>
  </div>

  <div id="platformer-game-screen" class="screen">
    <div class="panel">
      <h2>Plagues Adventure</h2>
      <div class="platformer-header">
        <div class="platformer-stat">Plague: <span id="platformer-level-name">N/A</span></div>
        <div class="platformer-stat">Staff Power: <span id="platformer-tokens">0</span></div>
        <div class="platformer-stat"><span class="hearts" id="platformer-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
      </div>
      <div id="platformer-canvas-container">
          <canvas id="platformer-canvas"></canvas>
          <div id="platformer-overlay">
              <h2 id="platformer-message"></h2>
              <button id="platformer-start-btn">Start Adventure üöÄ</button>
              <button id="platformer-next-level-btn" style="display:none;">Next Plague! ‚ú®</button>
              <button id="platformer-restart-btn" style="display:none;">Try Again</button>
          </div>
      </div>
    </div>
  </div>
</div>

<script>
// --- GLOBAL & MENU LOGIC ---
const initialGameState = { character: 'boy' };
let game = { ...initialGameState };

function switchScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
    
    // Stop any active game when switching screens
    if (platformerGame.active) platformerGame.endGame(false, true);
    if (memoryGame.timerId) clearInterval(memoryGame.timerId);
    if (sortingGame.active) sortingGame.endGame();
}

function resetAndGoHome() {
    game = { ...initialGameState };
    document.getElementById(`char-${game.character}`).checked = true;
    switchScreen('main-menu-screen');
}

document.getElementById('home-reset-btn').onclick = resetAndGoHome;

// --- 1. SORTING GAME ---
const sortingGame = {
    active: false,
    cardCount: 0,
    placedCount: 0,
    allActivities: {
        boy: {
            happy: [ { emoji: 'üôè', text: "Praying" }, { emoji: 'üßπ', text: "Chores" }, { emoji: 'üìñ', text: "Bible Reading" }, { emoji: 'ü§ó', text: "Sharing" } ],
            distraction: [ { emoji: 'üéÆ', text: "Too many games" }, { emoji: 'üò†', text: "Arguing" }, { emoji: 'üò´', text: "Complaining" }, { emoji: 'üì±', text: "Ignoring parents"} ]
        },
        girl: {
            happy: [ { emoji: 'üôè', text: "Prayer" }, { emoji: 'ü§ù', text: "Helping friends" }, { emoji: 'üìñ', text: "Personal Study" }, { emoji: 'üìù', text: "Meeting Prep" } ],
            distraction: [ { emoji: 'üì±', text: "Social media" }, { emoji: ' gossip', text: "Gossiping" }, { emoji: 'üëª', text: "Scary movies" }, { emoji: 'ü§î', text: "Worrying"} ]
        }
    },
    
    start() {
        this.active = true;
        this.placedCount = 0;
        this.loadCards();
    },

    loadCards() {
        const cardContainer = document.getElementById('cards-container');
        cardContainer.innerHTML = '';
        document.getElementById('makes-happy').innerHTML = '<h3>üëç Makes Jehovah Happy</h3>';
        document.getElementById('distraction').innerHTML = '<h3>ü§î Could Be a Distraction</h3>';

        const mode = game.character;
        const activities = [...this.allActivities[mode].happy, ...this.allActivities[mode].distraction];
        activities.sort(() => 0.5 - Math.random());
        this.cardCount = activities.length;

        activities.forEach((activity, idx) => {
            const card = document.createElement("div");
            card.className = "card";
            card.id = `card${idx}`;
            card.draggable = true;
            card.innerHTML = `<span class="emoji">${activity.emoji}</span><span>${activity.text}</span>`;
            
            const isHappy = this.allActivities[mode].happy.some(c => c.text === activity.text);
            card.dataset.correctZone = isHappy ? 'makes-happy' : 'distraction';
            
            card.addEventListener('dragstart', (e) => e.dataTransfer.setData("text", e.target.id));
            cardContainer.appendChild(card);
        });
        
        document.querySelectorAll('.dropzone').forEach(zone => {
            zone.ondragover = (e) => { e.preventDefault(); zone.classList.add('over'); };
            zone.ondragleave = (e) => zone.classList.remove('over');
            zone.ondrop = (e) => this.onDrop(e);
        });
    },

    onDrop(e) {
        e.preventDefault();
        let dropzone = e.target;
        while (!dropzone.classList.contains('dropzone')) dropzone = dropzone.parentElement;
        dropzone.classList.remove('over');
        
        const cardId = e.dataTransfer.getData("text");
        const card = document.getElementById(cardId);
        
        if (card.dataset.correctZone === dropzone.id) {
            dropzone.appendChild(card);
            card.draggable = false;
            card.style.borderColor = 'var(--accent-green)';
            this.placedCount++;
            if (this.placedCount === this.cardCount) {
                setTimeout(() => {
                    alert("Great job! You sorted them all!");
                    this.start(); // Restart for replay value
                }, 500);
            }
        } else {
            card.style.borderColor = 'var(--accent-red)';
            setTimeout(() => card.style.borderColor = '#ccc', 500);
        }
    },
    endGame() { this.active = false; }
};

// --- 2. MEMORY GAME ---
const memoryGame = {
    level: 1, timerId: null, matches: 0, goal: 0,
    isChecking: false, flippedCards: [],
    levelData: [
        { pairs: 4, grid: '2x4' }, { pairs: 6, grid: '3x4' }, { pairs: 8, grid: '4x4' },
        { pairs: 10, grid: '4x5' }, { pairs: 12, grid: '4x6' }
    ],
    
    start() {
        this.resetState();
        const currentLevel = this.levelData[this.level - 1];
        if (!currentLevel) {
            alert("Wow! You've completed all memory levels!");
            resetAndGoHome();
            return;
        }
        
        this.goal = currentLevel.pairs;
        this.updateUI();
        this.createGrid(currentLevel.pairs, currentLevel.grid);
    },

    createGrid(pairCount, gridLayout) {
        const grid = document.getElementById('memory-game-grid');
        grid.innerHTML = '';
        const [rows, cols] = gridLayout.split('x');
        grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        
        const cardEmojis = ['üôè','üìñ','ü§ù','üòä','üßπ','üé∂','ü§ó','‚ù§Ô∏è','üåü','üêë','ü¶Å','üïäÔ∏è'];
        let cardPool = cardEmojis.slice(0, pairCount);
        cardPool = [...cardPool, ...cardPool];
        cardPool.sort(() => 0.5 - Math.random());

        cardPool.forEach(emoji => {
            const cardEl = document.createElement('div');
            cardEl.classList.add('memory-card');
            cardEl.dataset.id = emoji;
            cardEl.innerHTML = `<div class="card-face card-back">?</div><div class="card-face card-front">${emoji}</div>`;
            cardEl.onclick = () => this.flipCard(cardEl);
            grid.appendChild(cardEl);
        });
    },

    flipCard(cardEl) {
        if (this.isChecking || cardEl.classList.contains('is-flipped') || this.flippedCards.length >= 2) return;
        cardEl.classList.add('is-flipped');
        this.flippedCards.push(cardEl);
        if (this.flippedCards.length === 2) this.checkForMatch();
    },

    checkForMatch() {
        this.isChecking = true;
        const [card1, card2] = this.flippedCards;
        if (card1.dataset.id === card2.dataset.id) {
            this.matches++;
            this.updateUI();
            setTimeout(() => {
                card1.classList.add('is-matched');
                card2.classList.add('is-matched');
                this.flippedCards = [];
                this.isChecking = false;
                if (this.matches === this.goal) this.levelComplete();
            }, 500);
        } else {
            setTimeout(() => {
                card1.classList.remove('is-flipped');
                card2.classList.remove('is-flipped');
                this.flippedCards = [];
                this.isChecking = false;
            }, 1000);
        }
    },
    
    levelComplete() {
        alert(`Level ${this.level} Complete!`);
        this.level++;
        this.start();
    },
    
    updateUI() {
        document.getElementById('memory-level').textContent = this.level;
        document.getElementById('memory-matches').textContent = `${this.matches} / ${this.goal}`;
    },

    resetState() {
        this.matches = 0;
        this.isChecking = false;
        this.flippedCards = [];
        if (this.timerId) clearInterval(this.timerId);
        this.timerId = null;
    }
};

// --- 3. PLATFORMER GAME ---
const platformerGame = {
    canvas: document.getElementById('platformer-canvas'),
    ctx: null, active: false, gameInterval: null, frame: 0,
    level: 1, lives: 3, tokens: 0,
    
    player: {
        x: 100, y: 300, w: 40, h: 60, vx: 0, vy: 0, speed: 4, walkSpeed: 2.5, runSpeed: 5, jumpPower: 17,
        grounded: false, doubleJumpUsed: false,
        animState: 'idle', animFrame: 0, facing: 'right', squash: 0
    },
    platforms: [], particles: [], goal: null, levelData: [],
    gravity: 0.7, camera: { x: 0 },

    levelDesigns: [
        {}, // Level 0 placeholder
        { name: "Nile to Blood",bgColor: ['#a02a2a', '#6b1c1c'], platformType: 'stone', tokens: 5,
          layout: [
            { x: 0, y: 400, w: 400 }, { x: 500, y: 320, w: 200 }, { x: 800, y: 250, w: 150 },
            { x: 1100, y: 350, w: 250 }, { x: 1500, y: 280, w: 180 }, { x: 1800, y: 400, w: 300, goal: true}
          ]
        },
        { name: "Frogs", bgColor: ['#298c7a', '#1f6758'], platformType: 'lilypad', tokens: 7,
          layout: [
            { x: 0, y: 400, w: 200 }, { x: 350, y: 350, w: 150 }, { x: 600, y: 400, w: 150 },
            { x: 900, y: 320, w: 180 }, { x: 1250, y: 250, w: 120 }, { x: 1500, y: 380, w: 200},
            { x: 1850, y: 300, w: 250, goal: true}
          ]
        },
        // ... Add layouts for remaining 8 plagues here
    ],
    
    init() {
        this.ctx = this.canvas.getContext('2d');
        this.setCanvasSize();
        window.addEventListener('resize', () => this.setCanvasSize());
        
        document.getElementById('platformer-start-btn').onclick = () => this.start(1);
        document.getElementById('platformer-next-level-btn').onclick = () => { this.start(this.level + 1); };
        document.getElementById('platformer-restart-btn').onclick = () => { this.start(this.level); };
        
        this.showOverlay("Plagues Adventure");
    },
    
    setCanvasSize() {
        const container = document.getElementById('platformer-canvas-container');
        this.canvas.width = 800; // Internal resolution
        this.canvas.height = 450;
        // CSS handles the display scaling
    },

    start(level) {
        this.hideOverlay();
        this.active = true;
        this.frame = 0;
        this.level = level;
        if(level === 1) { // Only reset lives/tokens on a fresh start
            this.lives = 3;
            this.tokens = 0;
        }
        
        this.player.x = 100;
        this.player.y = 300;
        this.player.vx = 0;
        this.player.vy = 0;
        this.camera.x = 0;
        this.particles = [];
        this.levelData = [];

        this.generateLevel();
        if (this.gameInterval) clearInterval(this.gameInterval);
        this.gameInterval = setInterval(() => this.loop(), 1000 / 60);
        this.addKeyListeners();
    },

    keys: {},
    addKeyListeners() {
        this.keys = {};
        const keydownHandler = e => {
            this.keys[e.code] = true;
            // Prevent space from scrolling page
            if(e.code === 'Space') e.preventDefault();
        };
        const keyupHandler = e => this.keys[e.code] = false;
        
        window.addEventListener('keydown', keydownHandler);
        window.addEventListener('keyup', keyupHandler);
        
        this.removeListeners = () => {
             window.removeEventListener('keydown', keydownHandler);
             window.removeEventListener('keyup', keyupHandler);
        };
    },
    
    generateLevel() {
        const design = this.levelDesigns[this.level];
        if (!design) { this.endGame(true); return; }

        this.platforms = design.layout.map(p => ({...p, h: (design.platformType === 'lilypad' ? 20 : 40) }));
        const goalPlatform = this.platforms.find(p => p.goal);
        this.goal = {x: goalPlatform.x + goalPlatform.w / 2 - 25, y: goalPlatform.y - 50, w: 50, h: 50};
        
        // Distribute tokens
        for(let i=0; i < design.tokens; i++){
            const p = this.platforms[Math.floor(Math.random() * (this.platforms.length -1))];
            this.levelData.push({ type: 'token', x: p.x + Math.random() * p.w, y: p.y - 40, w: 20, h: 20, collected: false });
        }
    },

    loop() {
        if(!this.active) return;
        this.updatePlayerState();
        this.updateWorld();
        this.draw();
        this.updateUI();
    },

    updatePlayerState() {
        const p = this.player;
        if (p.squash > 0) p.squash = Math.max(0, p.squash - 0.1);

        const moving = this.keys.KeyA || this.keys.ArrowLeft || this.keys.KeyD || this.keys.ArrowRight;
        p.speed = this.keys.ShiftLeft ? p.runSpeed : p.walkSpeed;

        if (this.keys.KeyA || this.keys.ArrowLeft) { p.vx = -p.speed; p.facing = 'left'; }
        else if (this.keys.KeyD || this.keys.ArrowRight) { p.vx = p.speed; p.facing = 'right'; }
        else { p.vx = 0; }
        
        if ((this.keys.KeyW || this.keys.ArrowUp || this.keys.Space)) {
            if (p.grounded) {
                p.vy = -p.jumpPower;
                p.grounded = false;
                p.squash = 1; // Trigger squash for jump
                this.spawnParticles(p.x + p.w / 2, p.y + p.h, 10, '#ffffff');
            } else if (!p.doubleJumpUsed) {
                p.vy = -p.jumpPower * 0.8;
                p.doubleJumpUsed = true;
                this.spawnParticles(p.x + p.w / 2, p.y + p.h/2, 15, 'rgba(255,255,255,0.7)');
            }
            this.keys.KeyW = this.keys.ArrowUp = this.keys.Space = false; // Prevent holding jump
        }

        p.vy += this.gravity;
        p.x += p.vx;
        
        // Collision with floor
        if (p.y + p.h + p.vy > this.canvas.height) {
            p.y = this.canvas.height - p.h;
            p.vy = 0;
            this.land();
        } else {
             p.y += p.vy;
        }

        let onPlatform = false;
        this.platforms.forEach(plat => {
            if (p.x + p.w > plat.x && p.x < plat.x + plat.w &&
                p.y + p.h >= plat.y && p.y + p.h <= plat.y + 20 && p.vy >= 0) {
                onPlatform = true;
                p.y = plat.y - p.h;
                p.vy = 0;
                this.land();
            }
        });
        if(!onPlatform) p.grounded = false;
        
        // Animation state
        if (!p.grounded) p.animState = p.vy < 0 ? 'jump' : 'fall';
        else if (moving) p.animState = this.keys.ShiftLeft ? 'run' : 'walk';
        else p.animState = 'idle';
        p.animFrame++;
    },
    
    land() {
        if (!this.player.grounded) {
            this.player.squash = 1; // Trigger squash for landing
            this.spawnParticles(this.player.x + this.player.w / 2, this.player.y + this.player.h, 15, '#d3b897'); // Dust puff
        }
        this.player.grounded = true;
        this.player.doubleJumpUsed = false;
    },
    
    updateWorld() {
        // Camera
        const targetX = this.player.x - this.canvas.width / 3;
        this.camera.x += (targetX - this.camera.x) * 0.1;
        
        // Particles
        this.particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life--;
            if (p.life <= 0) this.particles.splice(i, 1);
        });

        // Collectibles
        this.levelData.forEach(item => {
            if (item.type === 'token' && !item.collected && this.checkCollision(this.player, item)) {
                item.collected = true;
                this.tokens++;
            }
        });

        // Goal collision
        if (this.goal && this.checkCollision(this.player, this.goal)) {
            this.showOverlay(`Plague ${this.level} Cleared!`, true, false);
            this.endGame(true, true);
        }

        // Fall death
        if (this.player.y > this.canvas.height + 50) {
            this.loseLife();
        }
    },
    
    loseLife() {
        this.lives--;
        if (this.lives <= 0) {
            this.endGame(false);
            this.showOverlay("Game Over", false, true);
        } else {
            this.start(this.level); // Restart current level
        }
    },

    checkCollision(rect1, rect2) {
        return rect1.x < rect2.x + rect2.w &&
               rect1.x + rect1.w > rect2.x &&
               rect1.y < rect2.y + rect2.h &&
               rect1.y + rect1.h > rect2.y;
    },

    spawnParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5 - 1,
                life: Math.random() * 30 + 20, color
            });
        }
    },

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.drawBackground(); // Draw background first

        this.ctx.save();
        this.ctx.translate(-this.camera.x, 0);

        this.drawPlatforms();
        this.drawCollectibles();
        this.drawGoal();
        this.drawParticles();
        this.drawPlayer();
        
        this.ctx.restore();
    },
    
    drawBackground() {
        const design = this.levelDesigns[this.level];
        if (!design) return;

        const grad = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        grad.addColorStop(0, design.bgColor[0]);
        grad.addColorStop(1, design.bgColor[1]);
        this.ctx.fillStyle = grad;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Level-specific details
        if (this.level === 1) { // Nile to Blood
            // Pyramids
            this.ctx.fillStyle = '#4a2517';
            this.ctx.beginPath(); this.ctx.moveTo(150, 400); this.ctx.lineTo(250, 200); this.ctx.lineTo(350, 400); this.ctx.fill();
            this.ctx.fillStyle = '#6d3621';
            this.ctx.beginPath(); this.ctx.moveTo(400, 400); this.ctx.lineTo(475, 250); this.ctx.lineTo(550, 400); this.ctx.fill();
            // Palm trees will be drawn with platforms
        } else if (this.level === 2) { // Frogs
            // Reeds
            this.ctx.strokeStyle = '#2a5b4f';
            this.ctx.lineWidth = 3;
            for(let i=0; i < 20; i++) {
                const x = i * 50;
                const h = 50 + Math.random() * 50;
                this.ctx.beginPath(); this.ctx.moveTo(x, 450); this.ctx.lineTo(x, 450 - h); this.ctx.stroke();
            }
        }
    },

    drawPlatforms() {
        const design = this.levelDesigns[this.level];
        if (!design) return;
        
        this.platforms.forEach(p => {
            if(design.platformType === 'stone') {
                this.ctx.fillStyle = '#8d6e63'; this.ctx.fillRect(p.x, p.y, p.w, p.h);
                this.ctx.fillStyle = '#a1887f'; this.ctx.fillRect(p.x, p.y, p.w, 10);
            } else if (design.platformType === 'lilypad') {
                this.ctx.fillStyle = '#4caf50';
                this.ctx.beginPath(); this.ctx.ellipse(p.x + p.w / 2, p.y + p.h / 2, p.w / 2, p.h * 0.8, 0, 0, Math.PI * 2); this.ctx.fill();
                this.ctx.fillStyle = '#66bb6a';
                this.ctx.beginPath(); this.ctx.ellipse(p.x + p.w / 2, p.y + p.h / 2 - 2, p.w / 2 * 0.8, p.h * 0.7, 0, 0, Math.PI * 2); this.ctx.fill();
            }
        });
    },

    drawCollectibles() {
        this.levelData.forEach(item => {
            if (item.type === 'token' && !item.collected) {
                this.ctx.fillStyle = 'gold';
                this.ctx.beginPath();
                this.ctx.arc(item.x + item.w/2, item.y + item.h/2 + Math.sin(this.frame * 0.1) * 5, item.w/2, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.fillStyle = '#f9a825';
                this.ctx.fillText('S', item.x + 5, item.y + 15, 10);
            }
        });
    },

    drawGoal() {
        if (!this.goal) return;
        this.ctx.fillStyle = '#f4a261';
        this.ctx.globalAlpha = 0.5 + Math.sin(this.frame * 0.05) * 0.5;
        this.ctx.fillRect(this.goal.x, this.goal.y, this.goal.w, this.goal.h);
        this.ctx.globalAlpha = 1;
        this.ctx.fillStyle = 'white';
        this.ctx.font = '24px Fredoka One';
        this.ctx.fillText("üèÅ", this.goal.x + 10, this.goal.y + 35);
    },

    drawParticles() {
        this.particles.forEach(p => {
            this.ctx.fillStyle = p.color;
            this.ctx.globalAlpha = p.life / 40;
            this.ctx.fillRect(p.x, p.y, 4, 4);
            this.ctx.globalAlpha = 1;
        });
    },

    drawPlayer() {
        const p = this.player;
        const art = game.character === 'boy' ? 
            { tunic: '#4a90e2', skin: '#f2a66e', hair: '#3a2d27' } :
            { tunic: '#e91e63', skin: '#ffbe87', hair: '#8b572a' };
        
        let squashY = 1 - Math.sin(p.squash * Math.PI) * 0.3;
        let stretchX = 1 + Math.sin(p.squash * Math.PI) * 0.3;

        this.ctx.save();
        this.ctx.translate(p.x + p.w / 2, p.y + p.h);
        if (p.facing === 'left') this.ctx.scale(-1, 1);
        this.ctx.scale(stretchX, squashY);
        this.ctx.translate(-(p.x + p.w / 2), -(p.y + p.h));
        
        const bob = (p.animState === 'walk' || p.animState === 'run') ? Math.sin(this.frame * (p.speed / 20)) * 3 : 0;

        // Legs
        this.ctx.fillStyle = art.skin;
        this.ctx.fillRect(p.x + 8, p.y + 40, 10, 20);
        this.ctx.fillRect(p.x + 22, p.y + 40, 10, 20);

        // Tunic
        this.ctx.fillStyle = art.tunic;
        this.ctx.fillRect(p.x + 5, p.y + 15 + bob, 30, 30);
        
        // Head
        this.ctx.fillStyle = art.skin;
        this.ctx.beginPath();
        this.ctx.arc(p.x + p.w/2, p.y + 12 + bob, 12, 0, Math.PI*2);
        this.ctx.fill();

        // Hair
        this.ctx.fillStyle = art.hair;
        this.ctx.beginPath();
        this.ctx.arc(p.x + p.w/2, p.y + 8 + bob, 12, 0, Math.PI*2);
        this.ctx.fill();

        // Eyes
        this.ctx.fillStyle = 'white';
        this.ctx.beginPath();
        this.ctx.ellipse(p.x + p.w/2 + 5, p.y + 12 + bob, 4, 5, 0, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.fillStyle = 'black';
        this.ctx.beginPath();
        this.ctx.arc(p.x + p.w/2 + 6, p.y + 13 + bob, 2, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.restore();
    },

    showOverlay(message, showNext = false, showRestart = false) {
        const overlay = document.getElementById('platformer-overlay');
        document.getElementById('platformer-message').textContent = message;
        document.getElementById('platformer-start-btn').style.display = (!showNext && !showRestart) ? 'inline-block' : 'none';
        document.getElementById('platformer-next-level-btn').style.display = showNext ? 'inline-block' : 'none';
        document.getElementById('platformer-restart-btn').style.display = showRestart ? 'inline-block' : 'none';
        overlay.style.display = 'flex';
    },
    hideOverlay() { document.getElementById('platformer-overlay').style.display = 'none'; },
    
    endGame(isComplete = false, isSoftEnd = false) {
        this.active = false;
        clearInterval(this.gameInterval);
        if (this.removeListeners) this.removeListeners();
        if (isSoftEnd) return; // Don't show overlay if just resetting
        if (!isComplete) this.showOverlay("Game Over", false, true);
    },
    
    updateUI() {
        const design = this.levelDesigns[this.level] || {};
        document.getElementById('platformer-level-name').textContent = `${this.level}. ${design.name || 'Finished!'}`;
        document.getElementById('platformer-tokens').textContent = `${this.tokens}`;
        document.getElementById('platformer-lives').textContent = '‚ù§Ô∏è'.repeat(this.lives) + 'üñ§'.repeat(3 - this.lives);
    }
};

// --- INITIALIZATION & EVENT LISTENERS ---
window.onload = () => {
    document.getElementById('start-sorting-btn').onclick = () => {
        switchScreen('sorting-game-screen');
        sortingGame.start();
    };
    document.getElementById('start-memory-btn').onclick = () => {
        switchScreen('memory-game-screen');
        memoryGame.level = 1;
        memoryGame.start();
    };
    document.getElementById('start-platformer-btn').onclick = () => {
        switchScreen('platformer-game-screen');
        platformerGame.init();
    };
    document.getElementById('character-selector').onchange = (e) => {
        game.character = e.target.value;
    };
};
</script>
</body>
</html>
